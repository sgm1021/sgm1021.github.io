{"pages":[],"posts":[{"title":"Jupyter notebook","text":"Jupyter notebook mode 명령모드(esc) : 셀을 수정할때 사용 편집모드(enter) : 셀안의 내용을 수정할때 사용 style markdown(명령모드 + m) : 셀안에 설명을 작성할때 사용 code(명령모드 + y) : 파이썬 코드를 작성할때 사용 단축키 셀 실행 : shift + enter 셀 삭제 : (명령모드) x 되돌리기 : (명령모드) z 셀 생성 : (명령모드) a(위에), b(아래) 11+2 3 Magic Command 셀 내부에서 특별하게 동작하는 커멘드 % : 한 줄의 magic command를 동작 %% : 셀단의의 magic command를 동작 주요 magic command pwd : 현재 주피터 노트북 파일의 경로 ls : 현재 디렉토리의 파일 리스트 whos : 현재 선언된 변수를 출력 reset : 현재 선언된 변수를 삭제 1%pwd 'C:\\\\Code\\\\01_python' 1%ls Volume in drive C is Windows10 Volume Serial Number is E625-BBFB Directory of C:\\Code\\01_python 2021-01-21 �삤�썑 10:03 &lt;DIR&gt; . 2021-01-21 �삤�썑 10:03 &lt;DIR&gt; .. 2021-01-21 �삤�썑 09:53 &lt;DIR&gt; .ipynb_checkpoints 2021-01-21 �삤�썑 10:03 1,905 01_jupyter_notebook.ipynb 1 File(s) 1,905 bytes 3 Dir(s) 67,438,399,488 bytes free 1%whos Interactive namespace is empty. 1%reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y 1%whos Interactive namespace is empty. Shell Command 주피터 노트북을 실행 쉘 환경의 명령을 사용 명령어 앞에 !를 붙여서 실행 주요 명령어 ls, cat, echo … 1!echo python python 1!ls 01_jupyter_notebook.ipynb","link":"/2021/02/22/01_jupyter_notebook/"},{"title":"","text":"Numpy 데이터는 행렬 표현 행렬 데이터 빠르게 계산을 해야 합니다. 행렬 데이터 생성, 수정, 계산 등을 빠르게 처리해 주는 패키지 특징 C, C++, 포트란으로 작성 선형대수학을 빠르게 연산 스칼라, 벡터, 매트릭스 1import numpy as np 12# 행렬 데이터 생성# ndarray : 한가지 데이터 타입만 값으로 사용이 가능 12arrary = np.array([1, 2, 3])type(arrary), arrary (numpy.ndarray, array([1, 2, 3])) 12345arrary2 = np.array( [[1, 2, 3], [4, 5, 6]],)arrary2, arrary2.ndim, arrary2.shape (array([[1, 2, 3], [4, 5, 6]]), 2, (2, 3)) 12# 행렬의 모양(shape) 변경하기arrary2.reshape(3,2) array([[1, 2], [3, 4], [5, 6]]) 1# 행렬 데이터의 선택 : offset index : masking 1arrary2[1][::-1] array([6, 5, 4]) 1arrary2[1,2] # arrary2[1][2] 6 1# 데이터 수정 123ls = [1,2,3]ls[1] = 5ls [1, 5, 3] 12arrary2[1][2] = 10arrary2 array([[ 1, 2, 3], [ 4, 5, 10]]) 123# 브로드 캐스팅arrary2[0] = 0arrary2 array([[ 0, 0, 0], [ 4, 5, 10]]) 12arrary2[0] = [7, 8, 9]arrary2 array([[ 7, 8, 9], [ 4, 5, 10]]) 123# 조건으로 선택idx = arrary2 &gt;7idx array([[False, True, True], [False, False, True]]) 1arrary2[idx] array([ 8, 9, 10]) 12arrary2[idx] = 100arrary2 array([[ 7, 100, 100], [ 4, 5, 100]]) 123# 행렬 데이터의 생성 2data = np.zeros((2,3))data array([[0., 0., 0.], [0., 0., 0.]]) 1data.dtype dtype('float64') 12data2 = data.astype(&quot;int&quot;)data2.dtype dtype('int32') 12data = np.ones((2, 3, 2))data array([[[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]]]) 12# arangenp.arange(5) array([0, 1, 2, 3, 4]) 1np.arange(5,10) array([5, 6, 7, 8, 9]) 1np.arange(5, 10, 2) array([5, 7, 9]) 1","link":"/2021/03/05/01_numpy/"},{"title":"AWS server setting","text":"Server Setting OTP 설정 EC2 생성 FTP 서비스 : cyberduck 설치 pyenv 설정 jupyter notebook 설치 mysql 설치 및 설정 1. OTP 설정 AWS Console에서 내 보안 자격 증명 메뉴로 이동 멀티팩터인증(MFA) 선택 MFA 활성화 버튼 선택 가상 MFA 디바이스 선택 Authy 다운로드 및 회원가입 https://authy.com/download/ 이메일과 핸드폰 인증이 필요 모바일, 데스크탑, 크롬브라우져앱 설치 가능 Authy 앱 실행 Authy앱에서 Tokens에서 + 버튼을 클릭 AWS 페이지에서 비밀키 표시 버튼을 클릭하고 나온 문자열을 Authy 앱의 Enter Code given by the website에 입력 Account Name을 설정 후 Save 연속해서 나오는 Key값을 AWS 페이지의 MFA Key1, MFA Key2에 입력 2. EC2 생성 AWS Console에서 EC2 입력해서 서비스 페이지에 들어감 인스턴스 메뉴의 인스턴스 시작 클릭 Ubuntu Server 18.04 LTS 선택 t2.micro 선택 검토 및 시작 클릭 키페어 생성 및 다운로드 시작하기 버튼 클릭 접속 dss.pem 키파일 ~/.ssh 디렉토리로 이동 dss.pem 파일 권한 변경 $ chmod 400 ~/.ssh/dss.pem 서버 접속 ssh -i ~/.ssh/dss.pem ubuntu@&lt;public ip 주소&gt; 3. FTP 서비스 cyberduck https://cyberduck.io/download/ filezilla https://filezilla-project.org/download.php 서버 접속 설정 SFTP 선택 서버 : public ip 설정 사용자 이름 : ubuntu SSH Private Key : dss.pem 파일 선택 4. pyenv 설정 pyenv.sh 파일을 구글 드라이브에서 다운 cyberduck을 이용하여 서버로 파일 이동 pyenv.sh 파일 실행1$ source pyenv.sh 5. jupyter notebook 설치 및 설정 ipython jupyter 패키지 설치1$ pip install ipython jupyter 설정 파일 생성1$ jupyter notebook --generate-conﬁg 패스워드 생성123456$ ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: dssVerify password: dsssha1:6600c5733ef3:b683d6afba16b3403fdf9a75ac38b7d8e7f733bb 설정파일 접속1$ sudo vi /home/ubuntu/.jupyter/jupyter_notebook_conﬁg.py 설정 파일 수정123c.NotebookApp.ip = '172.31.26.225' # 내부 IP 주소c.NotebookApp.open_browser = Falsec.NotebookApp.password = 'sha1:6600c5733ef3:b683d6afba16b3403fdf9a75ac38b7d8e7f733bb' 서버의 8888 포트 활성화 서버에서 jupyter notebook 실행 브라우져로 접속 http://&lt;public ip&gt;:8888 6. Mysql 설치 및 설정 mysql-server, mysql-client 설치 $ sudo apt install mysql-server mysql 보안 설정 ( n-y-n-y-y 순으로 입력해줍니다. ) $ sudo mysql_secure_installation 1234567- Would you like to setup VALIDATE PASSWORD plugin? Press y|Y for Yes, any other key for No: n- 패스워드 설정 : dss- Remove anonymous users? (Press y|Y for Yes, any other key for No) : y- Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n- Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y- Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y 최초 패스워드 설정 123456$ sudo mysqlmysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'dss';mysql&gt; FLUSH PRIVILEGES;mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;mysql&gt; exit 접속 12$ mysql -u root -pEnter password: dss 외부 접속 허용 mysql 설정파일 bind-address = 0.0.0.0 으로 수정 $ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 1bind-address = 0.0.0.0 외부접속이 허용되도록 mysql 설정1mysql&gt; grant all privileges on *.* to 'root'@'%' identified by 'dss'; 재시작으로 설정 적용1$ sudo systemctl restart mysql.service 서버의 3306 포트 활성화 database management application windows heidiSQL https://www.sequelpro.com/ mac Sequel Pro https://www.heidisql.com Save Sample Data https://dev.mysql.com/doc/index-other.html world database zip 파일 다운로드 압축 해제 후 world.sql 파일을 서버로 이동 database management app을 이용하여 world 데이터 베이스 생성 데이터 저장 방법 11$ mysql -u root -p world &lt; world.sql 데이터 저장 방법 2123sql&gt; create database world;sql&gt; use world;sql&gt; source world.sql","link":"/2021/02/22/01_server_setting/"},{"title":"Jupyter notebook","text":"파이썬의 기본 문법 변수 선언, 식별자, 자료형, 형변환, 연산자 학습 1. 주석(comment)과 축력(print)123456789# 주석 : 앞에 #을 붙이면 코드로 실행이 안됩니다.# 코드에 대한 설명이나 중간에 코드를 샐행시키고 시퓨지 않을때 사용# 단축키 : ctrl(cmd) + /# 블럭설정 : shift + 방향키# 1,2,3을 출력하는 코드print(1)#print(2)print(3) 1 3 12# 출력 : print 함수# 코드 중간에 변수안에 들어있는 값을 확인하고 싶을때 사용 123456a = 1b = 2print(b)c = 3b = 4print(b) 2 4 12345# print 함수의 옵션# docstring : 함수에 대한 설명 : 단축키(shift + tab)# 자동완성 : tabprint(1,2, sep=&quot;-&quot;, end=&quot;\\t&quot;)print(3) 1-2 3 1python_data_science = 1 1python_data_science 1 2. 변수 선언 RAM 저장공간에 값을 할당하는 행위 123a = 1b = 2c = a + b 12d, e = 3, 4f = g = 5 3. 식별자 변수, 함수, 클래스, 모듈등의 이름을 식별자 라고 합니다. 식별자 규칙 소문자, 대문자, 숫자, 언더스코어(_)를 사용합니다. 가장 압에 숫자 사용 불가 예약어의 사용 불가 : def, class, try, except … 컨벤션 snake case : fast_campus : 변수, 함수_ camel case : FastCampus, fastCampus : 클래스 4. 데이터 다입 RAM 저장공간을 효율적으로 사용하기 위해 저장공간의 타입을 설정 동적타이핑 변수 선언시 저장되는 값에 따라서 자동으로 데이터 타입이 설정 기본 데이터 타입 : int, float, bool, str 컬렉션 데이터 타입 : list, tuple, dict 1234a = 1# int a = 1 b = &quot;python&quot;type(a), type(b) (int, str) 123456# 기본 데이터 타입 : int, float, bool, stra = 1b = 1.2c = Trued = &quot;data&quot;type(a),type(b),type(c),type(d) (int, float, bool, str) 1a + b 2.2 1a + d --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-22-4fbab87c839c&gt; in &lt;module&gt; ----&gt; 1 a + d TypeError: unsupported operand type(s) for +: 'int' and 'str' 123# 데이터 타입에 함수 : 문자열# upper : 대문자로 변환e = d.upper() 1d, e ('data', 'DATA') 1f = &quot;Fast Campus&quot; 12# lower : 소문자로 변환f.lower() 'fast campus' 12# strip : 공백제거f.strip() 'Fast Campus' 12# replace : 특정 문자열 치환f.replace(&quot;Fast&quot;, &quot;Slow&quot;) 'Slow Campus' 1f.replace(&quot; &quot;, &quot;&quot;) 'FastCampus' 1dir(f) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 123# 오프셋 인덱스 : 마스크, 마스킹 : []# 문자열은 순서가 있는 문자들의 집합g = &quot;abcdefg&quot; 1g[2], g[-2], g[2:5], g[:2], g[3:], g[-2:], g[::2], g[::-1] ('c', 'f', 'cde', 'ab', 'defg', 'fg', 'aceg', 'gfedcba') 1numbers = &quot;123456789&quot; # 97531 출력 12result = numbers[::2]result[::-1] '97531' 1numbers[::2][::-1] '97531' 1numbers[::-2] '97531' 컬렉션 데이터 타입 : list, tuple, dict list [] : 순서가 있는 수정이 가능한 데이터 타입 tuple () : 순서가 있는 수정이 불가능한 데이터 타입 dict {}: 순서가 없고 키:값 으로 구성된 데이터 타입 123# listls = [1,2,3,&quot;four&quot;, [5,6], True, 1.2]type(ls), ls (list, [1, 2, 3, 'four', [5, 6], True, 1.2]) 12# offset index 사용 가능ls[3], ls[1:3], ls[::-1] ('four', [2, 3], [1.2, True, [5, 6], 'four', 3, 2, 1]) 12# list 함수ls = [1, 5, 2, 4] 123# append : 가장 뒤에 값을 추가ls.append(3)ls [1, 5, 2, 4, 3] 123# sort : 오름차순으로 정렬ls.sort()ls[::-1] [5, 4, 3, 2, 1] 1234# pop : 가장 마지막 데이터를 출력하고 출력한 데이터를 삭제# ctrl + enter : 현재 셀을 계속 실행num = ls.pop()num, ls (3, [1, 2]) 1# 리스트의 복사 123ls1 = [1, 2, 3]ls2 = ls1 # 얕은 복사 : 주소값 복사ls1, ls2 ([1, 2, 3], [1, 2, 3]) 12ls1[2] = 5ls1, ls2 ([1, 2, 5], [1, 2, 5]) 12ls3 = ls1.copy()ls1, ls3 ([1, 2, 5], [1, 2, 5]) 1ls1[2] = 10 1ls1, ls3 ([1, 2, 10], [1, 2, 5]) Tuple 리스트와 같지만 수정이 불가능한 데이터 타입 튜플은 리스트보다 같은 데이터를 가졌을때 공간을 적게 사용 123tp1 = 1, 2, 3tp2 = (4, 5, 6)type(tp1), type(tp2), tp1, tp2 (tuple, tuple, (1, 2, 3), (4, 5, 6)) 12a, b = 1, 2a, b (1, 2) 12# offset index 사용 가능tp1[1], tp1[::-1] (2, (3, 2, 1)) 1234567# 리스트와 튜플의 저장공간 차이 비교import sysls = [1, 2, 3]tp = (1, 2, 3)print(sys.getsizeof(ls), sys.getsizeof(tp)) 80 64 dict {} 순서가 없고 {키:값}으로 구성된 데이터 타입 12345678# 선언 : 키는 정수, 문자열 데이터 타입만 사용 가능# 인덱스 대신 키를 사용dic = { 1: &quot;one&quot;, &quot;two&quot;: 2, &quot;three&quot; : [1, 2, 3],}type(dic), dic (dict, {1: 'one', 'two': 2, 'three': [1, 2, 3]}) 1dic[1], dic[&quot;three&quot;] ('one', [1, 2, 3]) 12dic[&quot;two&quot;] = 123dic {1: 'one', 'two': 123, 'three': [1, 2, 3]} 123# 아래의 데이터를 list와 dict로 선언# 도시 : seoul, busan, daegu# 인구 : 9,700,000, 3,400,00, 2,400,000 123# 리스트city = [&quot;seoul&quot;, &quot;busan&quot;, &quot;daegu&quot;]population = [9700000, 3400000, 2400000] 123456# 딕셔너리data = { &quot;seoul&quot; : 9700000, &quot;busan&quot; : 3400000, &quot;daegu&quot; : 2400000,} 1sum(population) 15500000 1sum(data.values()) 15500000 5. 형변환 데이터 타입을 변환하는 방법 int, float, bool, str, list, tuple, dict 123a = 1b = &quot;2&quot;a + int(b) 3 1str(a) + b '12' 1list(data.values()) [9700000, 3400000, 2400000] 1city, population (['seoul', 'busan', 'daegu'], [9700000, 3400000, 2400000]) 12# zip : 같은 인덱스 데이터끼리 묶어주는 함수list(zip(city, population)) [('seoul', 9700000), ('busan', 3400000), ('daegu', 2400000)] 1result = dict(zip(city, population)) 123data1 = list(result.keys())data2 = list(result.values())data1, data2 (['seoul', 'busan', 'daegu'], [9700000, 3400000, 2400000]) 12string = &quot;python&quot;int(string) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-113-3eb1982ee741&gt; in &lt;module&gt; 1 string = &quot;python&quot; ----&gt; 2 int(string) ValueError: invalid literal for int() with base 10: 'python' 6. 연산자 산술연산자 : +, -, *, /, //, %, ** 할당연산자 : 변수에 누적시켜서 연산 : +=, //=, **= 비교연산자 : &lt;, &gt;, ==, !=, &lt;=, &gt;= : 결과로 True, False 멤버연산자 : 특정 데이터가 있는지 확인할때 사용 : not in, in 논리연산자 : True, False를 연산 : or, and, not 12# 산술연산1 + 4 / 2 ** 2 2.0 12345# 할당연산a = 10a+=10a+=10a 30 1234# 비교연산b=2print(a, b)a &lt; b, a == b, a !=b 30 2 (False, False, True) 12# 논리연산True and False, True or False, not True or False (False, True, False) 12# 멤버연산ls = ['jin', 'andy', 'john'] 1'andy' in ls, 'anchel' in ls (True, False) 1234### 랜덤함수import randomrandom.randint(1, 10) 10 123# 입력함수data = input(&quot;insert string: &quot;)data insert string: 안녕하세요 '안녕하세요' 1# 해결의 책 : 질문을 하면 질문에 대한 답변을 해주는 책 1234# 솔루션을 리스트로 작성# 질문 입력 받음# 솔루션의 갯수에 맞게 랜덤한 index 정수 값을 생성# index 해당하는 솔루션 리스트의 데이터를 출력 123456789101112131415# 솔루션을 리스트로 작성solutions = [ &quot;무엇을 하든 잘 안될것이다.&quot;, &quot;생각지도 않게 좋은 일이 생길것이다.&quot;, &quot;무엇을 상상하든 그 이상이다.&quot;]# 질문 입력 받음input(&quot;질문을 입력하세요.: &quot;)# 솔루션의 갯수에 맞게 랜덤한 index 정수 값을 생성idx = random.randint(0, len(solutions) - 1)# index 해당하는 솔루션 리스트의 데이터를 출력solutions[idx] 질문을 입력하세요.: d '무엇을 하든 잘 안될것이다.' 1","link":"/2021/02/22/02_basic_syntax/"},{"title":"","text":"summary numpy : 선형대수를 빠르게 현산해주는 패키지 행렬의 생성 1 : ndarray, np.array(iterable) 행렬의 생성 2 : ones, zeros 행렬 데이터 선택 : array[x, y, z] 행렬 데이터 수정 행렬 데이터를 선택 =, &gt; (값(scala, vactor, matrix)) 브로드 캐스팅 개녕 arange : list에서 사용하는 range : 결과가 ndarray 1234### quiz- 1000 ~ 130 까지 랜덤한 숫자를 가지는 8*8행렬을 만들고,- 3의 배수는 fiz, 5의 배수는 buz, 3과 5의 배수는 fbz 문자로 변환- 랜덤한 행렬 데이터 datas = np.random.randint(100, 130, size=(8, 8)) 1- 데이터 타입이 정수 -&gt; 문자열 : ndarray.astype() 123import numpy as npdatas = np.random.randint(100, 130, size=(8, 8))datas array([[102, 102, 108, 128, 102, 114, 121, 111], [125, 118, 112, 105, 110, 119, 111, 114], [127, 109, 127, 101, 117, 113, 123, 109], [110, 123, 128, 102, 124, 127, 103, 109], [104, 106, 123, 115, 118, 117, 106, 110], [104, 120, 109, 108, 120, 126, 109, 101], [111, 107, 100, 118, 118, 118, 108, 104], [118, 111, 102, 126, 126, 120, 108, 115]]) 123data1 = np.array([1,2,3])data2 = [True, False, True]data1[data2] array([1, 3]) 1234# 3의 배수 , 5의 배수, 15의 배수 위치값에 대한 T, F matrix 생성idx_3 = datas % 3 == 0idx_5 = datas % 5 == 0idx_15 = datas % 15 == 0 12# 데이터 타입을 str으로 변환datas.dtype dtype('int32') 12result = datas.astype(&quot;str&quot;)result array([['113', '123', '107', '126', '102', '116', '109', '102'], ['103', '106', '103', '129', '109', '109', '115', '104'], ['125', '120', '103', '114', '102', '103', '129', '102'], ['114', '107', '120', '107', '118', '103', '110', '121'], ['101', '113', '114', '124', '101', '126', '115', '109'], ['125', '121', '101', '116', '124', '121', '108', '108'], ['129', '119', '119', '129', '108', '122', '114', '108'], ['101', '103', '126', '120', '127', '109', '127', '105']], dtype='&lt;U11') 1# T, F matrix를 이용하여 특정 조건의 데이터를 선택 후 브로트캐스팅하게 값을 대입 123result[idx_3] = &quot;fiz&quot;result[idx_5] = &quot;buz&quot;result[idx_15] = &quot;fbz&quot; 1result array([['113', 'fiz', '107', 'fiz', 'fiz', '116', '109', 'fiz'], ['103', '106', '103', 'fiz', '109', '109', 'buz', '104'], ['buz', 'fbz', '103', 'fiz', 'fiz', '103', 'fiz', 'fiz'], ['fiz', '107', 'fbz', '107', '118', '103', 'buz', '121'], ['101', '113', 'fiz', '124', '101', 'fiz', 'buz', '109'], ['buz', '121', '101', '116', '124', '121', 'fiz', 'fiz'], ['fiz', '119', '119', 'fiz', 'fiz', '122', 'fiz', 'fiz'], ['101', '103', 'fiz', 'fbz', '127', '109', '127', 'fbz']], dtype='&lt;U11') Quiz 1~20까지 랜덤한 숫자를 가지는 5*5 행렬 생성 최대값에는 MAX, 최소값에는 MIN 문자열이 들어가도록 치환하는 코드1np.min(ndarray), np.max(ndarray) 12datas = np.random.randint(1, 20, (5, 5))datas array([[ 9, 6, 10, 19, 4], [14, 8, 6, 6, 6], [15, 14, 6, 17, 12], [ 5, 9, 6, 13, 8], [16, 3, 9, 10, 13]]) 12min_num, max_num = np.min(datas), np.max(datas)min_num, max_num (3, 19) 12idx_min = datas == min_numidx_max = datas == max_num 1idx_min array([[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False], [False, True, False, False, False]]) 1idx_max array([[False, False, False, True, False], [False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]]) 12result = datas.astype(&quot;str&quot;)result array([['9', '6', '10', '19', '4'], ['14', '8', '6', '6', '6'], ['15', '14', '6', '17', '12'], ['5', '9', '6', '13', '8'], ['16', '3', '9', '10', '13']], dtype='&lt;U11') 123result[idx_min] = &quot;MIN&quot;result[idx_max] = &quot;MAX&quot;result array([['9', '6', '10', 'MAX', '4'], ['14', '8', '6', '6', '6'], ['15', '14', '6', '17', '12'], ['5', '9', '6', '13', '8'], ['16', 'MIN', '9', '10', '13']], dtype='&lt;U11') 1. linspace, logspace 함수 linspace : 설정한 범위에서 선형적으로 분할한 위치의 값을 출력 logspace : 설정한 범위에서 로그로 분할한 위치의 값을 축력 12# linspacenp.linspace(0, 100, 5) array([ 0., 25., 50., 75., 100.]) 123# logspace# Log10(X1)=2, log10(X2)=3, log10(X3)=4np.logspace(2, 4, 3) array([ 100., 1000., 10000.]) 12# 30세 연봉이 $100000 이고 60세의 연봉이 $1000000 일때# 연봉이 선형으로 증가, 지수함수로 증가하는 두 경우에서의 40, 50세 연봉을 출력 12age_30 = 100000age_60 = 1000000 1np.linspace(age_30, age_60, 4) array([ 100000., 400000., 700000., 1000000.]) 1np.logspace(np.log10(age_30), np.log10(age_60), 4) array([ 100000. , 215443.46900319, 464158.88336128, 1000000. ]) 2. numpy random seed : 램덤값을 설정값 rand : 균등분포로 랜덤한 값 생성 randn : 정규분포로 난수를 발생 randint : 균등분포로 정수값을 발생 suffle : 행렬 데이터를 섞어 줍니다. choice : 특정 확률로 데이터를 선택 1234567891011# seednp.random.seed(1)result1 = np.random.randint(10, 100, 10)np.random.seed(1)result2 = np.random.randint(10, 100, 10)np.random.seed(2)result3 = np.random.randint(10, 100, 10)result1, result2, result3 (array([47, 22, 82, 19, 85, 15, 89, 74, 26, 11]), array([47, 22, 82, 19, 85, 15, 89, 74, 26, 11]), array([50, 25, 82, 32, 53, 92, 85, 17, 44, 59])) 1np.random.rand(10) array([0.20464863, 0.61927097, 0.29965467, 0.26682728, 0.62113383, 0.52914209, 0.13457995, 0.51357812, 0.18443987, 0.78533515]) 123# shuffler = np.random.randint(1, 10, (3, 4))r array([[2, 3, 5, 8], [4, 5, 1, 2], [1, 9, 6, 9]]) 12np.random.shuffle(r)r array([[1, 9, 6, 9], [4, 5, 1, 2], [2, 3, 5, 8]]) 12#choicenp.random.choice(5, 10, p=[0.1, 0.4, 0.2, 0.3]) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-10-e648bb30cd70&gt; in &lt;module&gt; 1 #choice ----&gt; 2 np.random.choice(5, 10, p=[0.1, 0.4, 0.2, 0.3]) mtrand.pyx in numpy.random.mtrand.RandomState.choice() ValueError: 'a' and 'p' must have same size 1234# uniquenumber, counts = np.unique(r, return_counts=True)print(number)print(counts) [1 2 3 4 5 6 8 9] [2 2 1 1 2 1 1 2] 3. 행렬 데이터의 결합 concatenate 123na1 = np.random.randint(10, size=(2,3))na2 = np.random.randint(10, size=(3,2))na3 = np.random.randint(10, size=(3,3)) 12# 셀로 결합na1 array([[9, 3, 0], [3, 2, 6]]) 1na2 array([[8, 1], [8, 8], [2, 9]]) 1na3 array([[2, 0, 0], [2, 7, 7], [2, 3, 7]]) 1np.concatenate((na1, na3)) array([[9, 3, 0], [3, 2, 6], [2, 0, 0], [2, 7, 7], [2, 3, 7]]) 1np.concatenate((na2, na3,), axis=1) array([[8, 1, 2, 0, 0], [8, 8, 2, 7, 7], [2, 9, 2, 3, 7]]) 12# c_, r_np.c_[np.array([1,2,3]), np.array([4,5,6])] array([[1, 4], [2, 5], [3, 6]]) 1np.r_[np.array([1,2,3]), np.array([4,5,6])] array([1, 2, 3, 4, 5, 6]) 1# split, bar, std, mean ... 1","link":"/2021/03/05/02_numpy_2/"},{"title":"Jupyter notebook","text":"1. 조건문 특정 조건에 따라서 코드를 실행하고자 할때 사용 if, else, elif 12345# 조건부분에 bool 데이터 타입 이외의 테이터 타입이 오면 bool으로 형변환 되어 판단if False: print(&quot;python&quot;) print(&quot;done&quot;) done 12# int : 0을 제외한 나머지 값은 Truebool(0), bool(1), bool(-1), bool(100) (False, True, True, True) 12345678num = 0if num : print(&quot;python_1&quot;)num = 1if num : print(&quot;python_2&quot;) python_2 1234number = 7if number % 2: print(&quot;홀수&quot;) 홀수 123# float : 0.0을 제외한 나머지 실수는 True# str : &quot;&quot;를 제외한 나머지 문자열은 True# list, tuple, dict : [], (), {}를 제외한 나머지는 True 123456789# 지갑에 돈이 10000원 이상 있으면 택시를 타고 그렇지 않으면 걸어서 집에 갑니다.# 2000원 이상이면 버스money = 5000if money &gt;= 10000: print(&quot;택시&quot;) if money &lt; 10000: print(&quot;걸어서&quot;) 택시 1234if money &gt;= 10000: print(&quot;택시&quot;)else: print(&quot;걸어서&quot;) 택시 123456if money &gt;= 10000: print(&quot;택시&quot;)elif money &gt; 2000: print(&quot;버스&quot;)else: print(&quot;걸어서&quot;) 택시 12345# 계좌에 10000원이 들어 있다.# 인출 금액을 입력 받습니다.# 인출 금액이 계좌에 있는 금액보다 크면 &quot;잔액 부족&quot; 출력# 아니면 &quot;인출&quot; 출력# 마지막에 현재 잔액 출력 12data = int(input(&quot;draw money: &quot;))type(data), data draw money: 5000 (int, 5000) 110000 - data 5000 12345678910account = 10000draw_money = int(input(&quot;insert draw money: &quot;))if account &gt;= draw_money: account -= draw_money print(str(draw_money) + &quot;원 출금&quot;)else: print(&quot;잔액 부족, &quot;+ str(draw_money - account) + &quot;원 부족&quot;)print(&quot;현재 잔액 : &quot; + str(account) + &quot;원&quot;) insert draw money: 5000 5000원 출금 현재 잔액 : 5000원 123# string 데이터 타입의 format 함수print(&quot;현재 잔액은 {}원, 인출금액은 {}원 입니다.&quot;.format(account, draw_money))print(&quot;현재 잔액은 {data1}원, 인출금액은 {data2}원 입니다.&quot;.format(data2 = draw_money, data1 = account)) 현재 잔액은 5000원, 인출금액은 5000원 입니다. 현재 잔액은 5000원, 인출금액은 5000원 입니다. 1f'현재 {account}' '현재 5000' 삼항연산자 간단한 if, else 구문을 한줄의 코드로 표현할 수 있는 방법 (True) if (condition) else (False) 123456# data 변수에 0이면 &quot;zero&quot; 출력, 아니면 &quot;not zero&quot; 출력data = 0if data: print(&quot;not zero&quot;)else: print(&quot;zero&quot;) zero 123data = 1result = &quot;not zero&quot; if data else &quot;zero&quot;result 'not zero' 2. 반복문 반복되는 코드를 실행할 때 사용 while, for, break, continue list comprehention 123456# whiledata = 3while data:# 조건이 False가 될때까지 구문의 코드를 실행 # 반복되는 코드 print(data) data -= 1 3 2 1 12345678# 무한루프# break : 반복문을 중단 시킬때 사용되는 예약어result = 1while result: if result &gt;= 10: break result += 1print(result) 10 for iterable한 값을 하나씩 꺼내서 value에 대입시킨 후 코드를 iterable 변수의 값 갯수 만큼 실행12for &lt;variable&gt; in &lt;iterables&gt;: &lt;code&gt; 1234567# for : continue : 조건부분으로 올라가서 코드가 실행ls = [0, 1, 2, 3, 4]for data in ls: # data가 홀수면 continue 실행 if data % 2: continue # data가 짝수면 print 실행 print(data, end=&quot; &quot;) 0 2 4 1234567# for문을 이용하여 코드를 100번 실행# range 함수list(range(100))result = 0for data in range(100): result += dataresult 4950 12# offset index 개념과 비슷하게 사용list(range(5)), list(range(5, 10)), list(range(0, 10, 2)), list(range(10, 0, -2)) ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [0, 2, 4, 6, 8], [10, 8, 6, 4, 2]) 12345# 0~10 까지 짝수 합result = 0for number in range(0, 11, 2): result += numberresult 30 1dict = {&quot;one&quot;: 1, &quot;two&quot;:2, &quot;three&quot;:3} 123# 키값만 출력for data in dict: print(data) one two three 1list(dict.items()) [('one', 1), ('two', 2), ('three', 3)] 12for subject, point in dict.items(): print(subject, point) one 1 two 2 three 3 12345# 구구단for num2 in range(1, 10): for num1 in range(2, 10): print(&quot;{}*{}={}&quot;.format(num1, num2, num1*num2), end='\\t') print() 2*1=2 3*1=3 4*1=4 5*1=5 6*1=6 7*1=7 8*1=8 9*1=9 2*2=4 3*2=6 4*2=8 5*2=10 6*2=12 7*2=14 8*2=16 9*2=18 2*3=6 3*3=9 4*3=12 5*3=15 6*3=18 7*3=21 8*3=24 9*3=27 2*4=8 3*4=12 4*4=16 5*4=20 6*4=24 7*4=28 8*4=32 9*4=36 2*5=10 3*5=15 4*5=20 5*5=25 6*5=30 7*5=35 8*5=40 9*5=45 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 7*6=42 8*6=48 9*6=54 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 8*7=56 9*7=63 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 9*8=72 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 3. list comprehention 리스트 데이터를 만들어 주는 방법 for문 보다 빠르게 동작 123456# 각각 값에 제곡한 결과 출력ls = [0, 1, 2, 3]result = []for data in ls: result.append(data**2)result [0, 1, 4, 9] 12result = [data**2 for data in ls]result [0, 1, 4, 9] 123456789# 리스트 컴프리헨션을 써서 홀수와 짝수를 리스트로 출력해주는 코드# 삼항연산 사용ls = [0, 1, 2, 3]result = [&quot;짝수&quot;, &quot;홀수&quot;, &quot;짝수&quot;, &quot;홀수&quot;]result = [ &quot;홀수&quot; if data % 2 else &quot;짝수&quot; for data in ls]result ['짝수', '홀수', '짝수', '홀수'] 123# 리스트 컴프리헨션 조건문ls = range(10)[data for data in ls if data % 2] [1, 3, 5, 7, 9] 12ls = [1, 2, 3][func for func in dir(ls) if func[:2] != &quot;__&quot; and func[0] == 'c'] ['clear', 'copy', 'count'] 1# for문과 list comprehention 성능 비교 12345%%timeitls = []for num in range(1, 10001): ls.append(num)len(ls) 785 µs ± 23.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 123%%timeitls = [num for num in range(1, 10001) if num % 3 == 0]len(ls) 735 µs ± 3.17 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 1","link":"/2021/02/22/03_condition_loop/"},{"title":"Jupyter notebook","text":"함수 반복되는 코드를 묶음으로 효율적인 코드를 작성하도록 해주는 기능 기본 함수 파라미터와 아규먼트 리턴 ‘*args’, ‘**kwargs’ docstring scope inner function lambda function Map, Filter, Reduce Decorlator 1. 기본함수 함수의 선언과 호출 12345678point = 88if point &gt;= 90: print(&quot;A&quot;)elif point &gt;= 80: print(&quot;B&quot;)elif point &gt;= 70: print(&quot;C&quot;) B 1%reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y 1%whos Interactive namespace is empty. 12345678# 함수 선언def grade(point): if point &gt;= 90: print(&quot;A&quot;) elif point &gt;= 80: print(&quot;B&quot;) elif point &gt;= 70: print(&quot;C&quot;) 12a = 1ls = [1, 2, 3] 1%whos Variable Type Data/Info -------------------------------- a int 1 grade function &lt;function grade at 0x0000025592D26820&gt; ls list n=3 12# 함수 호출grade(88) B 1# code ... 1grade(78) C 2. 파라미터와 아규먼트 파라미터 : 함수를 선언할때 호툴하는 부분에서 보내주는 데이터를 받는 변수 아규먼트 : 함수를 호출할때 함수에 보내주는 데이터 12def plus(num1, num2=10, num3=20): # 파라미터 : 디폴트 파라미터 print(num1 + num2 - num3) 1plus(1, 2) # 아규먼트 3 1plus(3) # 아규먼트 13 1plus(3, num3=100) # 아규먼트 : 키워드 아큐먼트 -87 12print(1, 2, end=&quot;-&quot;)print(3) 1 2-3 3. 리턴 함수를 실행한 결과를 저장하고 싶을때 사용 return 123def plus(num1, num2): print(num1+num2) return num1+num2 12result = plus(1, 2)print(result) 3 3 123data1 = &quot;python&quot;result = data1.upper()print(result) PYTHON 123data2 = [3, 1, 2]result = data2.sort()print(result) None 12345# 함수에서 return 코드가 샐행되면 무조건 함수의 코드 실행이 종료def echo(msg): if msg == &quot;quit&quot;: return print(msg) 1echo(&quot;python&quot;) python 1echo(&quot;quit&quot;) 4. *args, **kwargs 함수를 호출할때 아규먼트와 키워드 아규먼트의 갯수를 특정지을수 없을때 사용 1234def plus(*args, **kwargs): print(type(args), args) print(type(kwargs), kwargs) return sum(args) + sum(list(kwargs.values())) 1plus(1, 2, num1=3, num2=4) &lt;class 'tuple'&gt; (1, 2) &lt;class 'dict'&gt; {'num1': 3, 'num2': 4} 10 1234def func(num1, num2, num3): return num1, num2, num3data = [1, 2, 3]func(*data) # func(1, 2, 3) (1, 2, 3) 12345data = { &quot;num2&quot;: 100, &quot;num3&quot;: 200,}func(1, **data) # func(1, num2=100, num3=200) (1, 100, 200) 1","link":"/2021/02/22/04_function/"},{"title":"Jupyter notebook","text":"%reset error ipython 버전을 downgrade conda uninstall ipython conda instapp ipython=7.2.0 conda install jupyter 함수 2 docstring scope inner function lambda function map, filter, reduce decorlator 1. Docstring 함수의 설명을 작성 12345678910def echo(msg): &quot;&quot;&quot; echo return its input agument The operation is: 1. print msg 2. return msg parameter param : msg : str return str &quot;&quot;&quot; return msg 1echo? 1echo?? 1help(echo) Help on function echo in module __main__: echo(msg) echo return its input agument The operation is: 1. print msg 2. return msg parameter param : msg : str return str 1print(echo.__doc__) echo return its input agument The operation is: 1. print msg 2. return msg parameter param : msg : str return str 2. Scope 범위 함수 안에서 선언되는 변수와 한수 밖에서 선언되는 변수의 범위가 다릅니다. global(전역), local(지역) 12345# globalgv = 10def echo(): print(gv)echo() 10 123456# globalgv = 10def echo(): gv = 100 print(gv)echo() 100 1gv 10 12345678# globalgv = 10def echo(): global gv gv = 100 print(gv)echo()gv # 100 100 100 3. Inner Function 함수가 지역영역에 선언, 함수 안에 함수가 선언 123456def outer(a, b): def inner(c, d): return c + d return inner(a, b) 1outer(1,2) 3 1inner(2, 3) --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-14-468e0d571ba5&gt; in &lt;module&gt; ----&gt; 1 inner(2, 3) NameError: name 'inner' is not defined 123456def outer(a, b): def inner(c, d): return c + d return inner 1outer(1,2)(3, 4) 7 1# callback function : 함수를 아규먼트 파라미터로 설정해서 사용 12345def calc(func, a, b): # code a **= 2 b **= 2 return func(a, b) 12def plus(a, b): return a + b 12def minus(a, b): return a - b 1calc(plus, 1, 2) # 덧셈 5 1calc(minus, 1, 2) # 뺄셈 -3 4. 람다함수 파라미터를 간단한 계산으로 리턴되는 함수 : 삼항연산 12def plus(a, b): return a + b 1plus(1, 2) 3 12plus2 = lambda a, b: a + bplus(1, 3) 4 12# calc(func, a, b)calc(lambda a, b: a + b, 3, 4) 25 1calc(plus, 3, 4) 25 5. map, filter, reduce map : 순서가 있는 데이터 집합에서 모든 값에 함수를 적용시킨 결과를 출력 12345ls = [1, 2, 3, 4]def odd_even(num): return &quot;odd&quot; if num%2 else &quot;even&quot; odd_even(3), odd_even(4) ('odd', 'even') 1list(map(odd_even, ls)) ['odd', 'even', 'odd', 'even'] 123# input 함수로 구분자로 &quot; &quot;으로 여러개의 숫자를 입력 받습니다.# str.split(&quot; &quot;) 리스트로 만들고# 만들어진 리스트의 값들을 int 형변환 1datas = input(&quot;insert numbers : &quot;) insert numbers : 10 20 30 40 50 60 12result = datas.split(&quot; &quot;)result ['10', '20', '30', '40', '50', '60'] 12result = list(map(int, result))result [10, 20, 30, 40, 50, 60] 1# ctrl + alt + 드래그 : 여러줄 수정 Filter 리스트 데이터에서 특정 조건에 맞는 value만 남기는 함수 1ls = range(10) 12# 홀수만 출력list(filter(lambda data: True if data % 2 else False, ls)) [1, 3, 5, 7, 9] Reduce 리스트 데이터를 처음부터 순서대로 특정 함수를 실행하여 결과를 누적시켜 주는 함수 1from functools import reduce 12ls = [3, 1, 2, 4, 5]reduce(lambda x, y : x + y, ls) 15 6. Decorlator 함수에서 코드를 바꾸지 않고 기능을 추가하거나 수정하고 싶을때 사용하는 문법 12345678910def a(): code_1 code_2 code_3 def b(): code_1 code_2 code_3 데코레이터의 사용 1234567891011121314151617def c(func): def wrapper(*args, **kwargs): code_1 result = func(*args, **kwargs) code_3 return result return wrapper @cdef a(): code_2@cdef b(): code_4 123456# adef plus(a, b): print(&quot;start&quot;) # code_1 result = a+b # code_2 print(f'result : {result}') # code_3 return result 123456# bdef minus(a, b): print(&quot;start&quot;) # code_1 result = a-b # code_4 print(f'result : {result}') # code_3 return result 12345678# cdef disp(func): def wrapper(*args, **kwargs): print(&quot;start&quot;) # code_1 result = func(*args, **kwargs) # code_2, code_4 print(f'result : {result}') # code_3 return result return wrapper 1plus(1, 2) start result : 3 3 1234@dispdef plus(a, b): result = a + b return result 1plus(1, 2) start result : 3 3 1# 데코레이터를 이용해서 함수의 실행 시간을 출력 1import time 12345678def timer(func): def wrapper(*args, **kwargs): start_time = time.time() # code_1 result = func(*args, **kwargs) # code_2, code_4 end_time = time.time() # code_3 print(&quot;running time : {}&quot;.format(end_time - start_time)) # code 3 return result return wrapper 1234@timerdef test1(num1, num2): data = range(num1, num2) return sum(data) 123456@timerdef test2(num1, num2): result = 0 for num in range(num1, num2+1): result += num return result 1test1(1, 100000) running time : 0.003003358840942383 4999950000 1test2(1, 100000) running time : 0.005014657974243164 5000050000 1# 패스워드를 입력 받아야 함수가 실행되도록하는 데코레이터 작성 1import random 1234567891011def check_password(func): def wrapper(*args, **kwargs): pw = &quot;dss11&quot; # check password input_pw = input(&quot;insert pw: &quot;) if input_pw == pw: result = func(*args, **kwargs) else: result = &quot;not allow!&quot; return result return wrapper 123@check_passworddef plus(a, b): return a+b 1plus(1, 2) insert pw: dss11 3 123456@check_passworddef lotto_func(): lotto = list(range(1, 46)) lotto = random.sample(lotto, 6) lotto.sort() return lotto 1lotto_func() insert pw: dss11 [4, 11, 12, 23, 26, 45] 1lotto_func() insert pw: asdf 'not allow!' 1","link":"/2021/02/22/05_function_2/"},{"title":"","text":"Pandas Pivot 데이터 프레임의 컬럼 데이터에서 index, column, value를 선택해서 데이터 프레임을 만드는 방법 df.pivot(index, columns, values) groupby 하고 pivot을 실행 df.pivot_table(values, index, columns, aggfunc) pandas io 데이터 프레임을 저장, 로드 123# lodtitanic = pd.read_csv(&quot;datas/train.csv&quot;)titanic.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 889 890 1 1 Behr, Mr. Karl Howell male 26.0 0 0 111369 30.00 C148 C 890 891 0 3 Dooley, Mr. Patrick male 32.0 0 0 370376 7.75 NaN Q 12# savetitanic.to_csv(&quot;datas/titanic.tsv&quot;, sep=&quot;\\t&quot;, index=False) 123# load : encodingdf = pd.read_csv(&quot;datas/2014_p.csv&quot;, encoding=&quot;euc_kr&quot;)df.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID RCTRCK RACE_DE RACE_NO PARTCPT_NO RANK RCHOSE_NM HRSMN RCORD ARVL_DFFRNC EACH_SCTN_PASAGE_RANK A_WIN_SYTM_EXPECT_ALOT WIN_STA_EXPECT_ALOT 27216 27217 제주 2014-11-29 9 7 6.0 미주여행 김경휴 0:01:31.1 13 2 - - - 2 - 3 - 6 6.2 9.4 27217 27218 제주 2014-11-29 9 6 1.0 철옹성 장우성 0:01:26.6 NaN 1 - - - 1 - 1 - 1 3.9 2.9 kaggle 데이터 분석, 모델을 경쟁할 수 있도록 만든 서비스 https://www.kaggle.com/ 1. 성별, 좌석등급에 따른 데이터의 수12df1 = titanic.groupby([&quot;Sex&quot;, &quot;Pclass&quot;]).size().reset_index(name=&quot;counts&quot;)df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Sex Pclass counts 0 female 1 94 1 female 2 76 2 female 3 144 3 male 1 122 4 male 2 108 5 male 3 347 123# pivotresult = df1.pivot(&quot;Sex&quot;, &quot;Pclass&quot;, &quot;counts&quot;)result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Pclass 1 2 3 Sex female 94 76 144 male 122 108 347 123# pivot table 이용titanic[&quot;counts&quot;] = 1titanic.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked counts 889 890 1 1 Behr, Mr. Karl Howell male 26.0 0 0 111369 30.00 C148 C 1 890 891 0 3 Dooley, Mr. Patrick male 32.0 0 0 370376 7.75 NaN Q 1 12result = titanic.pivot_table(&quot;counts&quot;, [&quot;Pclass&quot;], [&quot;Survived&quot;], aggfunc=np.sum)result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived 0 1 Pclass 1 80 136 2 97 87 3 372 119 12result[&quot;total&quot;] = result[0]+result[1]result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived 0 1 total Pclass 1 80 136 216 2 97 87 184 3 372 119 491 12result.loc[&quot;total&quot;] = result.loc[1] + result.loc[2] + result.loc[3]result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Survived 0 1 total Pclass 1 80 136 216 2 97 87 184 3 372 119 491 total 549 342 891 12df1 = pd.read_csv(&quot;datas/2014_p.csv&quot;, encoding=&quot;euc-kr&quot;)df1.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID RCTRCK RACE_DE RACE_NO PARTCPT_NO RANK RCHOSE_NM HRSMN RCORD ARVL_DFFRNC EACH_SCTN_PASAGE_RANK A_WIN_SYTM_EXPECT_ALOT WIN_STA_EXPECT_ALOT 27216 27217 제주 2014-11-29 9 7 6.0 미주여행 김경휴 0:01:31.1 13 2 - - - 2 - 3 - 6 6.2 9.4 27217 27218 제주 2014-11-29 9 6 1.0 철옹성 장우성 0:01:26.6 NaN 1 - - - 1 - 1 - 1 3.9 2.9 12df2 = pd.read_csv(&quot;datas/2014_s.csv&quot;, encoding=&quot;euc-kr&quot;)df2.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID RCTRCK RACE_DE PRDCTN_NATION_NM SEX AGE BND_WT TRNER RCHOSE_OWNR_NM RCHOSE_BDWGH 27216 27217 제주 2014-11-29 한 거 NaN 53.0 강대은 김기준 281 27217 27218 제주 2014-11-29 한 거 NaN 57.5 박병진 강상우 314 1","link":"/2021/03/05/05_pandas_3/"},{"title":"Jupyter notebook","text":"1234user_datas = [ {&quot;user&quot;:&quot;test&quot;, &quot;pw&quot;:&quot;1234&quot;, &quot;count&quot;:0}, {&quot;user&quot;:&quot;python&quot;, &quot;pw&quot;:&quot;5678&quot;, &quot;count&quot;:0},] 12345ls = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]print(list(range(len(ls))))print(list(zip(range(len(ls)), ls)))for idx, data in list(zip(range(len(ls)), ls)): print(idx, data) [0, 1, 2] [(0, 'a'), (1, 'b'), (2, 'c')] 0 a 1 b 2 c 1list(enumerate(user_datas)) [(0, {'user': 'test', 'pw': '1234', 'count': 0}), (1, {'user': 'python', 'pw': '5678', 'count': 1})] 123456789101112131415161718# user data를 입력 받아서 아이디와 패스워드를 체크하는 데코레이터 함수를 코드로 작성하세요.# 로그인 될때마다 count를 1씩 증가def need_login(func): def wrapper(*args, **kwargs): # 아이디 패스워드 입력 user, pw = tuple(input(&quot;insert user pw :&quot;).split(&quot; &quot;)) # 존재하는 아이디, 패스워드 확인 # for idx, user_data in zip(range(len(user_datas)), user_datas): for idx, user_data in enumerate(user_datas): if user_data[&quot;user&quot;] == user and user_data[&quot;pw&quot;] == pw: # count 데이터 추가 user_datas[idx][&quot;count&quot;] += 1 # 함수 실행 return func(*args, **kwargs) return &quot;wrong login data!&quot; # 카운트 증가 및 함수 실행 return wrapper 123@need_logindef plus(num1, num2): return num1 + num2 1plus(1, 2) insert user pw :test 1234 3 1user_datas [{'user': 'test', 'pw': '1234', 'count': 1}, {'user': 'python', 'pw': '5678', 'count': 2}] 1234# 스타크래프트의 마린을 클래스로 설계# 체력(health) = 40, 공격력(attack_pow) = 5, 공격(attack())# 마린 클래스로 마린 객체 2개를 생성해서 마린1이 마린2를 공격하는 코드를 작성# attack(self, unit) 12345678910111213class Marine: def __init__(self, health=40, attack_pow=5): self.health = health self.attack_pow = attack_pow def attack(self, unit): unit.health -= self.attack_pow print(unit.health) if unit.health &lt;= 0: unit.health = 0 print(&quot;사망&quot;) pass 1marine_1 = Marine() 1marine_2 = Marine() 1marine_1.attack(marine_2) 사망 1marine_1.health, marine_2.health # 40, 35 (40, 0) 123456789101112131415# 메딕 : heal_pow, heal(unit)class Medic: def __init__(self, health = 40, heal_pow=6): self.health = health self.heal_pow = heal_pow def heal(self, unit): if unit.health &gt; 0: unit.health += self.heal_pow if unit.health &gt;=40: unit.health = 40 else: print(&quot;이미 사망&quot;) 1medic = Medic() 1marine_1.attack(marine_2) 사망 1marine_1.health, marine_2.health (40, 0) 1medic.heal(marine_2) 이미 사망 1marine_3 = Marine(attack_pow=25) 1marine_3.attack(marine_1) 사망 1. 상속 클래스의 기능을 가져다가 기능을 수정하거나 추가할때 사용하는 방법 1234567class Calculator: def __init__(self, num1, num2): self.num1 = num1 self.num2 = num2 def plus(self): return self.num1 + self.num2 12calc = Calculator(1, 2)calc.plus() 3 12345678910class Calculator2: def __init__(self, num1, num2): self.num1 = num1 self.num2 = num2 def plus(self): return self.num1 + self.num2 def minus(self): return self.num1 - self.num2 1calc2 = Calculator2(1, 2) -1 1calc2.minus(), calc2.plus() (-1, 3) 1234# 상속을 사용하여 minus 함수 추가class Calculator3(Calculator): def minus(self): return self.num1 - self.num2 1calc3 = Calculator3(1, 2) 1calc3.plus(), calc3.minus() (3, -1) 12345# 메서드 오버라이딩class Calculator4(Calculator3): def plus(self): return self.num1**2 + self.num2**2 1calc4 = Calculator4(1, 2) 1calc4.plus() 5 1234# 아이폰 1, 2, 3# 아이폰 1 : calling : print(&quot;calling&quot;)# 아이폰 2 : send msg# 아이폰 3 : internet 123class iPhon1: def calling(self): print(&quot;calling&quot;) 123class iPhon2(iPhon1): def send_msg(self): print(&quot;send_msg&quot;) 123class iPhon3(iPhon2): def internet(self): print(&quot;internet&quot;) 1iphon3 = iPhon3() 1iphon3.calling(), iphon3.send_msg(), iphon3.internet() calling send_msg internet (None, None, None) 123class Galuxy: def show_img(self): print(&quot;show_img&quot;) 123class DssPhone(iPhon3, Galuxy): def camera(self): print(&quot;camera&quot;) 1dss_phone = DssPhone() 1[func for func in dir(dss_phone) if func[:2] != '__'] ['calling', 'camera', 'internet', 'send_msg', 'show_img'] 2. super 부모 클래스에서 사용된 함수의 코드를 가져다가 자식 클래스의 함수에서 재사용할때 사용 12345678class A: def plus(self): code1class B(A): def minus(self): code1 # super().plus() code2 12345678910class Marine: def __init__(self): self.health = 40 self.attack_pow = 5 def attack(self, unit): unit.health -= self.attack_pow if unit.health &lt;= 0: unit.health = 0 123456class Marine2(Marine): def __init__(self):# self.health = 40# self.attack_pow = 5 super().__init__() self.max_health = 40 1marine = Marine2() 1marine.health, marine.attack_pow, marine.max_health (40, 5, 40) 3. class의 getter, setter 객체의 내부 변수에 접근할때 특정 로직을 거쳐서 접근시키는 방법 12345678910111213141516171819class User: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name def setter(self, first_name): if len(first_name) &gt;= 3: self.first_name = first_name else: print(&quot;error&quot;) def getter(self): print(&quot;getter&quot;) return self.first_name.upper() def disp(self): print(self.first_name, self.last_name) name = property(getter, setter) 1user1 = User(&quot;andy&quot;, &quot;kim&quot;) 1user1.first_name 'andy' 12# getter 함수 실행user1.name getter 'ANDY' 12# setter 함수 실행user1.name = &quot;john&quot; 1user1.name getter 'JOHN' 4. non public mangling 이라는 방법으로 다이렉트로 객체의 변수에 접근하지 못하게 하는 방법 1234567891011121314151617181920class Calculator: def __init__(self, num1, num2): self.num1 = num1 self.__num2 = num2 def getter(self): return self.__num2 def setter(self, num2): num2 = 1 if num2 == 0 else num2 self.__num2 = num2 def __disp(self): print(self.num1, self.__num2) def div(self): self.__disp() return self.num1/self.__num2 number2 = property(getter, setter) 1calc = Calculator(1, 2) 1calc.div() 1 2 0.5 1calc.number2 2 1calc.number2 = 0 1calc.num2 = 0 1calc.div() 1 1 1.0 1calc.__num2 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-200-9422eadacb85&gt; in &lt;module&gt; ----&gt; 1 calc.__num2 AttributeError: 'Calculator' object has no attribute '__num2' 1calc._Calculator__num2 1 1calc.__disp() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-203-1997f957eed5&gt; in &lt;module&gt; ----&gt; 1 calc.__disp() AttributeError: 'Calculator' object has no attribute '__disp' 1calc._Calculator__disp() 1 1 5. is a &amp; has a 클래스를 설계하는 개념 A is a B A 는 B이다. 상속을 이용해서 클래스를 만드는 방법 A has a B A 는 B를 가진다. A는 B객체를 가지고 클래스를 만드는 방법 1# 사람 : 이름, 이메일, 정보출력() 12345# is aclass Person: def __init__(self, name, email): self.name = name self.email = email 123class Person2(Person): def info(self): print(self.name, self.email) 1p = Person2(&quot;andy&quot;, &quot;andy@gmail.com&quot;) 1p.info() andy andy@gmail.com 1234567# has aclass Name: def __init__(self, name): self.name_str = nameclass Email: def __init__(self, email): self.email_str = email 123456class Person: def __init__(self, name_obj, email_obj): self.nmae = name_obj self.email = email_obj def info(self): print(name.name_str, email.email_str) 123name = Name(&quot;andy&quot;)email = Email(&quot;andy@gmail.com&quot;)p = Person(name, email) 1p.info() andy andy@gmail.com Magic(Spacial) Method compare ‘eq‘: == ‘ne‘: != ‘lt‘: &lt; calculate ‘add‘: + ‘sub‘: - repr : 객체의 내용을 출력(개발자용) str : 객체의 내용을 출력 1&quot;test&quot; == &quot;test&quot; True 1&quot;test&quot;.__eq__(&quot;test&quot;) True 11+2 3 1'1'+'2' '12' 123456789101112class Txt: def __init__(self, txt): self.txt = txt def __eq__(self, txt_obj): return self.txt.lower() == txt_obj.txt.lower() def __repr__(self): return &quot;Txt(txt={})&quot;.format(self.txt) def __str__(self): return self.txt 123t1 = Txt(&quot;python&quot;)t2 = Txt(&quot;PYTHON&quot;)t3 = t1 1t1 == t2, t1 == t3, t2 == t3 (True, True, True) 1t1 Txt(txt=python) 1print(t1) python 1range(0, 5) range(0, 5) 12345678910111213# Integer 객체class Integer: def __init__(self, number): self.number = number def __add__(self, obj): return self.number + obj.number def __str__(self): return str(self.number) def __repr__(self): return str(self.number) 123num1 = Integer(1)num2 = Integer(2)num1 + num2 3 1num1 1 1num2 2 123# 계좌 클래스 만들기# 변수 : 자산(asset), 이자율(interest)# 함수 : 인출(draw), 입금(insert), 이자추가(add_interest) 1234567891011121314151617181920212223class Account: def __init__(self, asset=0, interest=1.05): self.asset = asset self.interest = interest def draw(self, money): if self.asset &gt;= money: self.asset -= money print(&quot;출금 : {}원&quot;.format(money)) else: print(&quot;금액부족 : {}원&quot;.format(money-self.asset)) def insert(self, money): self.asset += money print(&quot;{}원 입금&quot;.format(money)) def add_interest(self): self.asset *= self.interest print(&quot;이자 지급&quot;) def __repr__(self): return &quot;Account(asset:{}, interest:{})&quot;.format(self.asset, self.interest) 1account1 = Account(10000) 1account1 Account(asset:10000, interest:1.05) 1account1.draw(12000) 금액부족 : 2000원 1account1.insert(2000) 2000원 입금 1account1 Account(asset:12000, interest:1.05) 1account1.add_interest() 이자 지급 1account1 Account(asset:12600.0, interest:1.05) 1","link":"/2021/02/22/07_class_2/"},{"title":"Jupyter notebook","text":"class : 클래스 변수와 함수를 묶어 놓은 개념 사용 방법 변수와 함수가 들어있는 클래스를 선언 클래스를 객체로 만들어서 클래스 안에 선언된 변수와 함수를 사용 1. 기본 클래스의 사용12345678910# 클래스의 선언class Calculator: num1 = 1 num2 = 2 def plus(self): return self.num1 + self.num2 def minus(self): return self.num1 - self.num2 123# 클래스의 사용calc = Calculator()calc &lt;__main__.Calculator at 0x1d17368fca0&gt; 1calc.num1, calc.num2, calc.plus(), calc.minus() (1, 2, 3, -1) 12# self의 의미 : 객체 자신calc2 = Calculator() 1calc2.num1 = 10 1calc2.plus() 12 2. 객체지향 실체 세계를 코드에 반영해서 개발하는 방법 여러명의 개발자가 코드를 효율적으로 작성해서 프로젝트를 완성시키기 위한 방법 설계도 작성(class) -&gt; 실제 물건(object) 사용자 정의 데이터 타입 1calc2.plus() 12 12obj = &quot;python&quot;obj.upper() 'PYTHON' 12ls = [1, 3, 2]ls.sort() 1ls [1, 2, 3] 1[data for data in dir(calc) if data[:2] != '__'] ['minus', 'num1', 'num2', 'plus'] 3. 생성자 클래스가 객체로 생성될때 실행되는 함수 변수(재료)를 추가할때 사용됩니다. 1234567891011class Calculator: # 생정자 함수 : __init__ def __init__(self, num1, num2=10): self.num1 = num1 self.num2 = num2 def plus(self): return self.num1 + self.num2 def minus(self): return self.num1 - self.num2 1calc1 = Calculator(3) 1calc1.plus() 13 1calc2 = Calculator(3, 5) 1calc2.plus() 8 1234# joinls = [&quot;python&quot;, &quot;is&quot;, &quot;good&quot;]sep = &quot; &quot;sep.join(ls) 'python is good' 12# pandas dataframeimport pandas as pd 12345df = pd.DataFrame([ {&quot;name&quot;:&quot;jin&quot;, &quot;age&quot;:20}, {&quot;name&quot;:&quot;andy&quot;, &quot;age&quot;:21},])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name age 0 jin 20 1 andy 21 1","link":"/2021/02/22/06_class_1/"},{"title":"Jupyter notebook","text":"Module Package 모듈 : 변수와 함수, 클래스를 모아놓은 (.py) 확장자를 가진 파일 패키지 : 모듈의 기능을 디렉토리별로 정리해 놓은 개념 1. 모듈 모듈 생성 모듈 호출 12345678910111213%%writefile dss.pynum = 1234def disp1(msg): print(&quot;disp1&quot;, msg) def disp2(msg): print(&quot;disp2&quot;, msg)class Calc: def plus(self, *args): return sum(args) Writing dss.py 1!ls 01_jupyter_notebook.ipynb 02_basic_syntax.ipynb 03_condition_loop.ipynb 04_function.ipynb 05_function_2.ipynb 06_class_1.ipynb 07_class_2.ipynb 08_module_package.ipynb dss.py 1%reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y 1%whos Interactive namespace is empty. 12# 모듈 호출 : importimport dss 1%whos Variable Type Data/Info ------------------------------ dss module &lt;module 'dss' from 'C:\\\\Code\\\\01_python\\\\dss.py'&gt; 1dss.num 1234 1dss.disp1(&quot;python&quot;) disp1 python 1calc = dss.Calc() 1calc.plus(1,2,3,4) 10 1import random 1random.randint(1, 5) 1 1# 모듈 안에 특정 함수, 변수, 클래스 호출 1from dss import num, disp2 1%whos Variable Type Data/Info -------------------------------- calc Calc &lt;dss.Calc object at 0x0000026C12554340&gt; disp2 function &lt;function disp2 at 0x0000026C12626670&gt; dss module &lt;module 'dss' from 'C:\\\\Code\\\\01_python\\\\dss.py'&gt; num int 1234 random module &lt;module 'random' from 'C:&lt;...&gt;aconda3\\\\lib\\\\random.py'&gt; 1dss.num 1234 1num 1234 1%reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y 1from dss import * 1%whos Variable Type Data/Info -------------------------------- Calc type &lt;class 'dss.Calc'&gt; disp1 function &lt;function disp1 at 0x0000026C12626940&gt; disp2 function &lt;function disp2 at 0x0000026C12626670&gt; num int 1234 2. Package 패키지 생성 패키지 호출 setup.py 패키지 설치 파일 만들기 1# 디렉토리 생성 1!mkdir -p school/dss The syntax of the command is incorrect. 1!mkdir -p school/web The syntax of the command is incorrect. tree 설치 mac homebrew : https://brew.sh/ homebrew : osx 패키지 설치 관리툴 ‘/bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;' brew install tree 1!tree school Folder PATH listing for volume Windows10 Volume serial number is E625-BBFB C:\\CODE\\01_PYTHON\\SCHOOL ├───dss └───web 12# 패키지 사용시 디렉토리에 __init__.py 파일을 추가# python 3.3 버전 이상에서는 필요없음 12!touch school/dss/__init__.py!touch school/web/__init__.py 1!tree school Folder PATH listing for volume Windows10 Volume serial number is E625-BBFB C:\\CODE\\01_PYTHON\\SCHOOL ├───dss └───web 12345%%writefile school/dss/data1.pydef plus(*args): print(&quot;data1&quot;) return sum(args) Writing school/dss/data1.py 12345%%writefile school/dss/data2.pydef plus2(*args): print(&quot;data2&quot;) return sum(args) Writing school/dss/data2.py 1234%%writefile school/web/url.pydef make(url): return url if url[:7] == &quot;http://&quot; else &quot;http://&quot; + url Writing school/web/url.py 1!tree school/ Folder PATH listing for volume Windows10 Volume serial number is E625-BBFB C:\\CODE\\01_PYTHON\\SCHOOL ├───dss └───web 1%reset Once deleted, variables cannot be recovered. Proceed (y/[n])? y 1import school.dss.data1 1whos Variable Type Data/Info ------------------------------ school module &lt;module 'school' (namespace)&gt; 1school.dss.data1.plus(1,2,3) data1 6 1import school.dss.data1 as dss 1dss.plus(1,2) data1 3 123# school.web : 디렉토리# url : 모듈from school.web import url 1url.make(&quot;google.com&quot;) 'http://google.com' 1url.make(&quot;naver.com&quot;) 'http://naver.com' 1# 패키지의 위치 : 특정 디렉토리에 있는 패키지는 어디에서나 import 가능 1import random 1!ls 01_jupyter_notebook.ipynb 02_basic_syntax.ipynb 03_condition_loop.ipynb 04_function.ipynb 05_function_2.ipynb 06_class_1.ipynb 07_class_2.ipynb 08_module_package.ipynb __pycache__ dss.py school 1234import sysfor path in sys.path: print(path) C:\\Code\\01_python C:\\Users\\USER\\anaconda3\\python38.zip C:\\Users\\USER\\anaconda3\\DLLs C:\\Users\\USER\\anaconda3\\lib C:\\Users\\USER\\anaconda3 C:\\Users\\USER\\anaconda3\\lib\\site-packages C:\\Users\\USER\\anaconda3\\lib\\site-packages\\win32 C:\\Users\\USER\\anaconda3\\lib\\site-packages\\win32\\lib C:\\Users\\USER\\anaconda3\\lib\\site-packages\\Pythonwin C:\\Users\\USER\\anaconda3\\lib\\site-packages\\IPython\\extensions C:\\Users\\USER\\.ipython 12packages = !ls C:\\Users\\USER\\anaconda3\\liblen(packages) 207 1packages[-5:] ['xml', 'xmlrpc', 'zipapp.py', 'zipfile.py', 'zipimport.py'] 12# setup.py 를 작성해서 패키지를 설치해서 사용# setuptools를 이용 1!tree school/ Folder PATH listing for volume Windows10 Volume serial number is E625-BBFB C:\\CODE\\01_PYTHON\\SCHOOL ├───dss │ └───__pycache__ └───web └───__pycache__ 123%%writefile school/dss/__init__.py__all__ = [&quot;data1&quot;, &quot;data2&quot;] Overwriting school/dss/__init__.py 123456789101112%%writefile school/setup.pyfrom setuptools import setup, find_packagessetup( nume=&quot;dss&quot;, packages=find_packages(), include_package_data=True, version=&quot;0.0.1&quot;, author_email=&quot;manimahn12@gmail.com&quot; zip_safe=False) Overwriting school/setup.py 1!rm dss.py 1# 패키지 설치 확인 1!pip list | grep dss # dss가 들어간 패키지 확인 grep: #: No such file or directory grep: dss媛�: No such file or directory grep: �뱾�뼱媛�: No such file or directory grep: �뙣�궎吏�: No such file or directory grep: �솗�씤: No such file or directory ERROR: Pipe to stdout was broken Exception ignored in: &lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='cp949'&gt; OSError: [Errno 22] Invalid argument 12345# 패키지 설치# school $ python setup.py develop# 커널 리스타트# develop : 개발자모드, 코드를 수정하면 설치된 패키지도 같이 수정# build : 일반모드, 코드를 수정하면 다시 설치해야 수정된 코드가 적용 1!pip list | grep dss 1!pip list | grep numpy numpy 1.19.2 numpydoc 1.1.0 1from dss import * 1%whos Variable Type Data/Info ------------------------------ dss module &lt;module 'school.dss.data1&lt;...&gt;\\\\school\\\\dss\\\\data1.py'&gt; np module &lt;module 'numpy' from 'C:\\&lt;...&gt;ges\\\\numpy\\\\__init__.py'&gt; packages SList ['__future__.py', '__phel&lt;...&gt;file.py', 'zipimport.py'] path str C:\\Users\\USER\\.ipython random module &lt;module 'random' from 'C:&lt;...&gt;aconda3\\\\lib\\\\random.py'&gt; school module &lt;module 'school' (namespace)&gt; sys module &lt;module 'sys' (built-in)&gt; url module &lt;module 'school.web.url' &lt;...&gt;on\\\\school\\\\web\\\\url.py'&gt; 1data1.plus(1,2) --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-64-572e254ac59d&gt; in &lt;module&gt; ----&gt; 1 data1.plus(1,2) NameError: name 'data1' is not defined 12# uninstall# pip uninstall dss 1!pip list | grep dss 1","link":"/2021/02/22/08_module_package/"},{"title":"Try Except","text":"예외처리 코드를 실행중에 에러가 발생한 경우 에러를 처리하는 방법 try, except, finally, raise 12# try, except : 에러가 발생해도 코드의 실행을 계속하고 싶을때ls = [1, 2, 3] 12print(ls[3])print(&quot;Done!&quot;) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-4-f88f334466aa&gt; in &lt;module&gt; ----&gt; 1 print(ls[3]) 2 print(&quot;Done!&quot;) IndexError: list index out of range 123456try: print(ls[3])except Exception as e: print(&quot;error&quot;) print(e)print(&quot;Done&quot;) error list index out of range Done 1234567# finally : try, except 구문 실행된 후 finally 구문이 실행try: 1/0except: print(&quot;error&quot;)finally: print(&quot;Done!&quot;) error Done! 1# raise : 강제로 에러를 발생시키는 명령 1234567try: 1/0except Exception as e: print(&quot;error&quot;) raise(e)print(&quot;Done!&quot;) error --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) &lt;ipython-input-9-bcde7d6d4636&gt; in &lt;module&gt; 3 except Exception as e: 4 print(&quot;error&quot;) ----&gt; 5 raise(e) 6 7 print(&quot;Done!&quot;) &lt;ipython-input-9-bcde7d6d4636&gt; in &lt;module&gt; 1 try: ----&gt; 2 1/0 3 except Exception as e: 4 print(&quot;error&quot;) 5 raise(e) ZeroDivisionError: division by zero 12# 에러 생성 : 10이상의 숫자가 입력되도록 하는 에러# LowNumber 1234class LowNumber(Exception): def __str__(self): return &quot;Number grater than 10&quot; 1234def input_number(num): if num &lt;= 10: raise LowNumber() print(num) 1input_number(8) --------------------------------------------------------------------------- LowNumber Traceback (most recent call last) &lt;ipython-input-15-8684a0e33c0b&gt; in &lt;module&gt; ----&gt; 1 input_number(8) &lt;ipython-input-13-2dcc4faaa999&gt; in input_number(num) 1 def input_number(num): 2 if num &lt;= 10: ----&gt; 3 raise LowNumber() 4 print(num) LowNumber: Number grater than 10 1","link":"/2021/02/22/09_try_except/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/05/hello-world/"},{"title":"hexo gitblog 만들기","text":"목차개요1.파일 설치2.깃허브 설정3.블로그 만들기4.깃허브에 배포하기5.테마 설정하기6.다른 환경에서 작업하기 개요 Hexo 블로그를 만들어 본다. 파일 설치 1단계 : nodejs.org 다운로드 설치가 되었는지 확인해본다. 1$ node -v 2단계 : git-scm.com 다운로드 설치가 되었는지 확인해본다. 1$ git --version 3단계 : hexo 설치 npm을 통해 hexo를 설치한다. 1$ npm install -g hexo-cli 깃허브 설정 두개의 깃허브 Repo를 생성한다. 포스트 버전관리 (name : myblog) 포스트 배포용 관리 (name : USERNAME.github.io) USERNAME 대신에 본인의 username을 입력하면 된다. 생성 후, myblog repo를 git clone을 통해 적당한 경로에 내려 받는다. 1$ git clone your_git_repo_address.git 블로그 만들기 내려받은 myblog의 경로를 찾아 들어간다. myblog폴더 안에 임의의 블로그 파일명을 만든다. 12345$ hexo init gitblog # 임의의 파일명$ cd gitblog$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save _config.yml 파일 수정 싸이트 정보 수정 1234title: 제목을 지어주세요subtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그 URL 정보 설정 1234url: https://USERNAME.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 12345# Deploymentdeploy: type: git repo: https://github.com/USERNAME/USERNAME.github.io.git branch: main 깃허브에 배포하기 배포 전, 로컬환경에서 블로그가 뜨는지 확인해본다. 1234$ hexo generate$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 확인이 되면 깃허브에 배포한다. 사전에, gitignore 파일에서 아래와 같이 설정을 진행한다. 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 최종적으로 배포을 진행한다. 1$ hexo deploy 배포가 완료가 되면 브라우저에서 USERNAME.github.io로 접속해 정상적으로 배포가 되었는지 확인한다. 테마 설정하기 ICARUS 테마로 변경 1$ git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus ICARUS 테마 파일을 themes 폴더 안에 이식하는 코드다. 그 다음, _config.yml에서 theme: icarus로 변경한다. 그 다음, hexo server 실행 시, 에러가 날 것이다. - 에러 예제 1234567ERROR Package bulma-stylus is not installed.ERROR Package hexo-component-inferno is not installed.ERROR Package hexo-renderer-inferno is not installed.ERROR Package inferno is not installed.ERROR Package inferno-create-element is not installed.ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.2.4 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 위와 같은 에러가 발생하면, 출력되는 에러 문구에 따라 패키지들을 설치한다. 1234567$ npm install bulma-stylus$ npm install hexo-component-inferno$ npm install hexo-renderer-inferno$ npm install inferno$ npm install inferno-create-element$ npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3$ hexo server # 로컬에서 확인 로컬 테스트가 완료되면, 깃허브로 배포를 진행한다. 1$ hexo deploy --generate 마지막으로, 포스트 버전관리를 위해 수정된 내용을 깃허브에 업데이트를 진행한다. 123$ git add .$ git commit -m &quot;add: new post updated&quot;$ git push origin master 다른 환경에서 작업하기 새로운 위치에 myblog를 clone해 준다. myblog폴더 안에 gitblog폴더 로 이동 후, hexo server로 확인을 하면 에러가 날 것이다. - 에러 예제 123ERROR Cannot find module 'hexo' from 'C:\\myblog\\gitblog'ERROR Local hexo loading failed in C:\\myblog\\gitblogERROR Try running: 'rm -rf node_modules &amp;&amp; npm install --force' 출력된 문구에 따라 실행해 준다. 12rm -rf node_modules &amp;&amp; npm install --forcehexo server 로컬에서 확인이 완료되면 블로그 작업을 한다. 블로그 작업이 끝나면, 위와 같이 deploy로 배포하고, 깃허브에 push해 업데이트 까지 완료해준다.","link":"/2021/02/14/make_hexo_gitblog/"},{"title":"","text":"Pandas 데이터 분석을 위한 사용이 쉽고 성능이 좋은 오픈소스 python 라이브러리 R과 Pandas의 특징 R보다 Pandas가 학습이 쉽습니다. R보다 Pandas가 성능이 좋습니다. R보다 Python은 활용할 수 있는 분야가 많습니다. 크게 두가지 데이터 타입을 사용합니다. Serise : index와 value로 이루어진 데이터 타입 DataFrame : index, column, value로 이루어진 데이터 타입 12import numpy as npimport pandas as pd 1. Series 동일한 데이터 타입의 값을 갖습니다. 123# Series : value 만 설정하면 index는 0부처 자동으로 설정됩니다.data = pd.Series(np.random.randint(10, size=5))data 0 3 1 4 2 5 3 0 4 3 dtype: int32 123# index 설정data = pd.Series(np.random.randint(10, size=5), index=list('ABCDE'))data A 0 B 7 C 1 D 8 E 2 dtype: int32 1data.index, data.values (Index(['A', 'B', 'C', 'D', 'E'], dtype='object'), array([0, 7, 1, 8, 2])) 1data[&quot;B&quot;], data.B (7, 7) 12data[&quot;C&quot;] = 10data A 0 B 7 C 10 D 8 E 2 dtype: int32 12# 브로드 캐스팅data * 10 A 0 B 70 C 100 D 80 E 20 dtype: int32 1data[[&quot;B&quot;,&quot;C&quot;]] B 7 C 10 dtype: int32 12# offset indexdata[2::2] C 10 E 2 dtype: int32 1data[::-1] E 2 D 8 C 10 B 7 A 0 dtype: int32 1# Series 연산 1data A 0 B 7 C 10 D 8 E 2 dtype: int32 12data2 = pd.Series({&quot;D&quot;:3, &quot;E&quot;:5, &quot;F&quot;:7})data2 D 3 E 5 F 7 dtype: int64 12result = data + data2result # None A NaN B NaN C NaN D 11.0 E 7.0 F NaN dtype: float64 1result.isnull() A True B True C True D False E False F True dtype: bool 12result[result.isnull()] = dataresult A 0.0 B 7.0 C 10.0 D 11.0 E 7.0 F NaN dtype: float64 12result[result.isnull()] = data2result A 0.0 B 7.0 C 10.0 D 11.0 E 7.0 F 7.0 dtype: float64 2. DataFrame 데이터 프레임은 여러개의 Series로 구성 같은 컬럼에 있는 value값은 같은 데이터 타입을 갖습니다. 1# 데이터 프레임 생성 1 : 딕셔너리의 리스트 12345datas = { &quot;name&quot;:[&quot;dss&quot;, &quot;fcamp&quot;], &quot;Email&quot;:[&quot;dss@gmail.com&quot;,&quot;fcamp@daum.net&quot;]}datas {'name': ['dss', 'fcamp'], 'Email': ['dss@gmail.com', 'fcamp@daum.net']} 12df = pd.DataFrame(datas)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name Email 0 dss dss@gmail.com 1 fcamp fcamp@daum.net 1# 데이터 프레임 생성 2 : 리스트의 딕셔너리 12345datas = [ {&quot;name&quot;:&quot;dss&quot;, &quot;email&quot;:&quot;dss@gmail.com&quot;}, {&quot;name&quot;:&quot;fcamp&quot;, &quot;email&quot;:&quot;fcamp@daum.net&quot;},]datas [{'name': 'dss', 'email': 'dss@gmail.com'}, {'name': 'fcamp', 'email': 'fcamp@daum.net'}] 12df = pd.DataFrame(datas)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email 0 dss dss@gmail.com 1 fcamp fcamp@daum.net 123# 인덱스를 추가하는 방법df = pd.DataFrame(datas, index = [&quot;one&quot;, &quot;two&quot;])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email one dss dss@gmail.com two fcamp fcamp@daum.net 1df.index Index(['one', 'two'], dtype='object') 1df.columns Index(['name', 'email'], dtype='object') 1df.values array([['dss', 'dss@gmail.com'], ['fcamp', 'fcamp@daum.net']], dtype=object) 1# 데이터 프레임에서 데이터의 선택 : row, column, (row, column) 123# row 선택 : locdf = pd.DataFrame(datas)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email 0 dss dss@gmail.com 1 fcamp fcamp@daum.net 1df.loc[1][&quot;email&quot;] 'fcamp@daum.net' 123# index가 있으면 수정, 없으면 추가df.loc[2] = {&quot;name&quot;:&quot;andy&quot;, &quot;email&quot;:&quot;andy@naver.com&quot;}df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email 0 dss dss@gmail.com 1 fcamp fcamp@daum.net 2 andy andy@naver.com 1# column 선택 1df[&quot;name&quot;] 0 dss 1 fcamp 2 andy Name: name, dtype: object 12df[&quot;id&quot;] = &quot;&quot;df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id 0 dss dss@gmail.com 1 fcamp fcamp@daum.net 2 andy andy@naver.com 12df[&quot;id&quot;] = range(1, 4) # np.arange(1, 4)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id 0 dss dss@gmail.com 1 1 fcamp fcamp@daum.net 2 2 andy andy@naver.com 3 1df.dtypes name object email object id int32 dtype: object 1# row, column 선택 1df.loc[[0,2], [&quot;email&quot;, &quot;id&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } email id 0 dss@gmail.com 1 2 andy@naver.com 3 1# 컬럼 데이터 순서 설정 1df[[&quot;id&quot;, &quot;name&quot;, &quot;email&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id name email 0 1 dss dss@gmail.com 1 2 fcamp fcamp@daum.net 2 3 andy andy@naver.com 1# head, tail 1df.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id 0 dss dss@gmail.com 1 1 fcamp fcamp@daum.net 2 1df.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id 1 fcamp fcamp@daum.net 2 2 andy andy@naver.com 3 3. apply 함수 map 함수와 비슷 12# email 컬럽에서 메일의 도메인만 가져와서 새로운 domain컬럼을 생성df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id 0 dss dss@gmail.com 1 1 fcamp fcamp@daum.net 2 2 andy andy@naver.com 3 1234def domain(email): return email.split(&quot;@&quot;)[1].split(&quot;.&quot;)[0]domain(df.loc[0][&quot;email&quot;]) 'gmail' 1df[&quot;domain&quot;] = df[&quot;email&quot;].apply(domain) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id domain 0 dss dss@gmail.com 1 gmail 1 fcamp fcamp@daum.net 2 daum 2 andy andy@naver.com 3 naver 12df[&quot;domain&quot;] = df[&quot;email&quot;].apply(lambda email:email.split(&quot;@&quot;)[1].split(&quot;.&quot;)[0])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name email id domain 0 dss dss@gmail.com 1 gmail 1 fcamp fcamp@daum.net 2 daum 2 andy andy@naver.com 3 naver 1from makedata import * 1get_name() 'Alvin' 1get_age() 30 123df1= pd.DataFrame(make_data(5))df2= pd.DataFrame(make_data(5))df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 0 40 Billy 1 32 Anchal 2 35 Alvin 3 22 Andrew 4 27 Andrew 4. append123# append 데이터 프레임 합치기df3 = df1.append(df2)df3[2:7] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 2 34 Alvin 3 29 Billy 4 25 Anchal 0 40 Billy 1 32 Anchal 123# reset_index 인덱스 재정렬df3.reset_index(drop=True, inplace=True)df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 0 21 Alan 1 27 Alan 2 34 Alvin 3 29 Billy 4 25 Anchal 5 40 Billy 6 32 Anchal 7 35 Alvin 8 22 Andrew 9 27 Andrew 12df3 = df1.append(df2, ignore_index=True)df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 0 21 Alan 1 27 Alan 2 34 Alvin 3 29 Billy 4 25 Anchal 5 40 Billy 6 32 Anchal 7 35 Alvin 8 22 Andrew 9 27 Andrew 5. concat row나 column으로 데이터 프레임을 합칠때 사용 12df3 = pd.concat([df1, df2]).reset_index(drop=True)df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 0 21 Alan 1 27 Alan 2 34 Alvin 3 29 Billy 4 25 Anchal 5 40 Billy 6 32 Anchal 7 35 Alvin 8 22 Andrew 9 27 Andrew 1pd.concat([df3, df1], axis=1, join=&quot;inner&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name Age Name 0 21 Alan 21 Alan 1 27 Alan 27 Alan 2 34 Alvin 34 Alvin 3 29 Billy 29 Billy 4 25 Anchal 25 Anchal group by 특정 컬럽의 중복되는 데이터를 합쳐서 새로운 데이터 프레임을 만드는 방법 12df = pd.DataFrame(make_data())df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age Name 0 35 Alvin 1 26 Arnold 2 26 Jin 3 23 Anchal 4 30 Adam 5 21 Arnold 6 33 Adam 7 21 Adam 8 24 Alvin 9 32 Andrew 123# sizeresult_df = df.groupby(&quot;Name&quot;).size().reset_index(name=&quot;count&quot;)result_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name count 0 Adam 3 1 Alvin 2 2 Anchal 1 3 Andrew 1 4 Arnold 2 5 Jin 1 1# sort_values : 설정한 컬럼으로 데이터 프레임을 정렬 123result_df.sort_values([&quot;count&quot;], ascending = False, inplace = True)result_df.reset_index(drop=True, inplace=True)result_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name count 0 Adam 3 1 Alvin 2 2 Arnold 2 3 Anchal 1 4 Andrew 1 5 Jin 1 12# agg# size(), min(), max(), mean() 1df.groupby(&quot;Name&quot;).agg(&quot;min&quot;).reset_index() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Age 0 Adam 21 1 Alvin 24 2 Anchal 23 3 Andrew 32 4 Arnold 21 5 Jin 26 12# 데이터를 요약해서 보여주는 함수df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Age count 10.000000 mean 27.100000 std 5.087021 min 21.000000 25% 23.250000 50% 26.000000 75% 31.500000 max 35.000000 7. Merge = sql(join) 두개 이상의 데이터 프레임을 합쳐서 결과를 출력하는 방법 1","link":"/2021/03/05/03_pandas_1/"},{"title":"","text":"summary pandas 데이터 분석 : 데이터 전처리 파트 테이블 형태의 데이터를 처리할때 사용하는 python 라이브러리 Series, DataFrame Series 생성, 선택, 수정 방법 DataFrame 생성 방법 1 : 딕셔너리의 리스트 : 리스트 -&gt; 컬럼 데이터 생성 방법 2 : 리스트의 딕셔너리 : 딕셔너리 -&gt; 로우 데이터 row 선택 : df.loc[idx] column 선택 : df[column name] row, column 선택 : df.loc[idx, column] 함수 apply, append, concat groupby, merge 1import makedata 1makedata.get_age(), makedata.get_name() (21, 'Billy') 1makedata.make_data() [{'Age': 32, 'Name': 'Alvin'}, {'Age': 26, 'Name': 'Alan'}, {'Age': 25, 'Name': 'Anthony'}, {'Age': 40, 'Name': 'Anthony'}, {'Age': 35, 'Name': 'Billy'}, {'Age': 39, 'Name': 'Anthony'}, {'Age': 30, 'Name': 'Andrew'}, {'Age': 24, 'Name': 'Andrew'}, {'Age': 31, 'Name': 'Anthony'}, {'Age': 40, 'Name': 'Andrew'}] quiz makedata 모듈을 이용해서 데이터 프레임 만들기 user_df 8명의 데이터가 있는 데이터 프레임을 만드세요. UserID : 1 ~ 8 Name : makedata.get_name() Age : makedata.get_age() 중복되는 Name 값이 없도록 123456789101112131415# 딕셔너리의 리스트 : UserID, Name, Agedatas = {}datas[&quot;UserID&quot;] = list(range(1, 9))datas[&quot;Age&quot;] = [makedata.get_age() for _ in range(8)]names = []while True: name = makedata.get_name() if name not in names: names.append(name) if len(names) &gt;= 8: breakdatas[&quot;Name&quot;] = namesuser_df = pd.DataFrame(datas)user_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } UserID Age Name 0 1 22 Anchal 1 2 35 Andrew 2 3 29 Anthony 3 4 21 Billy 4 5 35 Arnold 5 6 32 Alan 6 7 34 Alvin 7 8 22 Adam 1234567891011121314# 딕셔너리 데이터를 데이터 프레임에 하나씩 추가하기 : UserID, Name, Ageuser_df = pd.DataFrame(columns=[&quot;UserID&quot;, &quot;Name&quot;, &quot;Age&quot;])for idx in range(1, 9): name = makedata.get_name() while name in list(user_df[&quot;Name&quot;]): name = makedata.get_name() data = {&quot;Name&quot;: name, &quot;UserID&quot;: idx, &quot;Age&quot;: makedata.get_age()} user_df.loc[len(user_df)] = datauser_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } UserID Name Age 0 1 Billy 23 1 2 Adam 26 2 3 Anchal 23 3 4 Alan 39 4 5 Alvin 20 5 6 Andrew 32 6 7 Arnold 22 7 8 Alex 30 quiz money_df 만들기 15개의 데이터 ID : 1 ~ 8 랜덤한 숫자 데이터 Money : 1000원 단위로 1000원 ~ 20000원까지의 숫자가 저장 12345678910111213# 딕셔너리 데이터를 데이터 프레임에 하나씩 추가하기money_df = pd.DataFrame(columns=[&quot;ID&quot;, &quot;Money&quot;])# np.random.randint(1, 9)for _ in range(15): money_df.loc[len(money_df)] = { &quot;ID&quot;: np.random.randint(1, 9), &quot;Money&quot;: np.random.randint(1, 21) * 1000, } # 컬럼데이터에서 Unique 값 확인ids = money_df[&quot;ID&quot;].unique()ids.sort()len(ids), ids (6, array([1, 2, 3, 5, 6, 7], dtype=object)) 1money_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Money 0 5 20000 1 6 5000 2 2 9000 3 7 4000 4 3 13000 5 2 14000 6 1 3000 7 1 16000 8 2 6000 9 6 13000 10 7 9000 11 1 16000 12 1 10000 13 2 15000 14 7 14000 1user_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } UserID Name Age 0 1 Billy 23 1 2 Adam 26 2 3 Anchal 23 3 4 Alan 39 4 5 Alvin 20 5 6 Andrew 32 6 7 Arnold 22 7 8 Alex 30 1. merge1user_df.merge(money_df, left_on=&quot;UserID&quot;, right_on=&quot;ID&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } UserID Name Age ID Money 0 1 Billy 23 1 3000 1 1 Billy 23 1 16000 2 1 Billy 23 1 16000 3 1 Billy 23 1 10000 4 2 Adam 26 2 9000 5 2 Adam 26 2 14000 6 2 Adam 26 2 6000 7 2 Adam 26 2 15000 8 3 Anchal 23 3 13000 9 5 Alvin 20 5 20000 10 6 Andrew 32 6 5000 11 6 Andrew 32 6 13000 12 7 Arnold 22 7 4000 13 7 Arnold 22 7 9000 14 7 Arnold 22 7 14000 123# 컬럼명 변경user_df.rename(columns={&quot;UserID&quot;:&quot;ID&quot;}, inplace=True)user_df.tail(1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age 7 8 Alex 30 1user_df.merge(money_df).tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age Money 13 7 Arnold 22 9000 14 7 Arnold 22 14000 12result_df = pd.merge(money_df, user_df)result_df.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Money Name Age 10 3 13000 Anchal 23 11 1 3000 Billy 23 12 1 16000 Billy 23 13 1 16000 Billy 23 14 1 10000 Billy 23 123# groupby : sum, size, min .. 함수 : Seriesmoney_list = result_df.groupby(&quot;Name&quot;).sum()[&quot;Money&quot;].reset_index()money_list .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Money 0 Adam 44000 1 Alvin 20000 2 Anchal 13000 3 Andrew 18000 4 Arnold 27000 5 Billy 45000 123# groupby : agg(&quot;sum&quot;), agg(&quot;mean&quot;) .. : DataFramemoney_list = result_df.groupby(&quot;Name&quot;).agg(&quot;sum&quot;).reset_index()[[&quot;Name&quot;, &quot;Money&quot;]]money_list .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Money 0 Adam 44000 1 Alvin 20000 2 Anchal 13000 3 Andrew 18000 4 Arnold 27000 5 Billy 45000 1# merge : money_list, user_df : outer 12result = pd.merge(user_df, money_list, how=&quot;outer&quot;)result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age Money 0 1 Billy 23 45000.0 1 2 Adam 26 44000.0 2 3 Anchal 23 13000.0 3 4 Alan 39 NaN 4 5 Alvin 20 20000.0 5 6 Andrew 32 18000.0 6 7 Arnold 22 27000.0 7 8 Alex 30 NaN 1# fillna : NaN 을 특정 데이터로 채워줌 12result.fillna(value=0, inplace=True)result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age Money 0 1 Billy 23 45000.0 1 2 Adam 26 44000.0 2 3 Anchal 23 13000.0 3 4 Alan 39 0.0 4 5 Alvin 20 20000.0 5 6 Andrew 32 18000.0 6 7 Arnold 22 27000.0 7 8 Alex 30 0.0 12# money 컬럼을 정수로 데이터 타입을 변경result.dtypes ID int64 Name object Age int64 Money float64 dtype: object 12result[&quot;Money&quot;] = result[&quot;Money&quot;].astype(&quot;int&quot;)result .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age Money 0 1 Billy 23 45000 1 2 Adam 26 44000 2 3 Anchal 23 13000 3 4 Alan 39 0 4 5 Alvin 20 20000 5 6 Andrew 32 18000 6 7 Arnold 22 27000 7 8 Alex 30 0 1result.sort_values(&quot;Money&quot;, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } ID Name Age Money 0 1 Billy 23 45000 1 2 Adam 26 44000 6 7 Arnold 22 27000 4 5 Alvin 20 20000 5 6 Andrew 32 18000 2 3 Anchal 23 13000 3 4 Alan 39 0 7 8 Alex 30 0 1np.average(result.sort_values(&quot;Money&quot;, ascending=False)[:3][&quot;Age&quot;]) 23.666666666666668","link":"/2021/03/05/04_pandas_2/"},{"title":"제 1고지 미분 자동계산","text":"1단계 상자로서의 변수1.1 변수란 데이터를 저장하는 상자와 같다 1.2 Variable 클래스 구현 DeZero에서 사용하는 변수라는 개념을 Variable이라는 이름의 클래스로 구현 클래스 이름의 첫글자는 보통 대문자 파이썬이 권장하는 코딩 규칙은 PEP8 PEP8 : 파이썬 개선 제안서, 파이썬 코드를 어떻게 구상할 지 알려주는 스타일 가이드 1234# steps/step01.pyclass Variable: def __init__(self, data): self.data = data __init__에 주어진 인수를 인스턴스 변수 data에 대입 Variable의 data에 보관 123456# steps/step01.pyimport numpy as npdata = np.array(1.0)x = Variable(data)print(x.data) 1.0 이 예에서 상자에 넣는 데이터로 ‘넘파이 다차원 배열’을 사용 x는 Variable 인스턴스 이며, 실제 데이터는 x안에 담겨 있음 x는 데이터 자체가 아니라 데이터의 담는 상자 즉, 변수 머신러닝 시스템은 기본 데이터 구조로 ‘다차원 배열’을 사용 DeZero의 Variable 클래스는 넘파이의 다차원 배열만 취급 넘파이 배열은 np.array 함수로 생성 가능 numpy.ndarray 인스턴스를 ndarray 인스턴스로 부름 123# steps/step01.pyx.data = np.array(2.0) # x에 새로운 데이터 대입print(x.data) 2.0 1.3 넘파이 다차원 배열 다차원 배열은 숫자 등의 원소가 일정하게 모여 있는 데이터 구조 다차원 배열에서 원소의 순서에는 방향이 있고, 이 방향을 차원(dimension) 혹은 축(axis)이라고 함 0차원, 1차원, 2차원 배일이 있는데, 차례대로 스칼라(scalar), 벡터(vector), 행렬(matrix)이라고 함 스칼라는 단순히 하나의 수 벡터는 하나의 축을 따라 숫자가 늘어서 있음 행렬은 축이 두 개 다차원 배열을 0차원 텐서(tensor), 1차원 텐서, 2차원 텐서라고도 함 1234# ndim 은 'number of dimensions'의 약자로, 다차원 배열의 '차원 수'를 뜻함import numpy as npx = np.array(1)x.ndim 0 12x = np.array([1, 2, 3])x.ndim 1 123x = np.array([[1, 2, 3], [4, 5, 6]])x.ndim 2 2단계 변수를 낳는 함수2.1 함수란 어떤 변수로부터 다른 변수로의 대응 관계를 정한 것 2.2 Function 클래스 구현 Function 클래스는 Variable 인스턴스를 입력받아 Variable 인스턴스를 출력 Variable 인스턴스의 실제 데이터는 인스턴스 변수인 data에 있음 123456class Function: def __call__(self, input): x = input.data # 데이터를 꺼냄 y = x ** 2 # 실제 계산 output = Variable(y) # Variable 형태로 되돌림 return output __call__ 메서드는 파이썬의 특수 메서드 f = Function() 형태로 함수의 인스턴스를 변수 f에 대입해 둠 f(…)형태로 __call__ 메서드를 호출할 수 있음 2.3 Function 클래스 이용12345x = Variable(np.array(10))f = Function()y = f(x)print(type(y))print(y.data) &lt;class '__main__.Variable'&gt; 100 Function 클래스는 기반 클래스로서, 모든 함수에 공통되는 기능을 구현 구체적인 함수는 Function 클래스를 상속한 클래스에서 구현 123456789# steps/step02.pyclass Function: def __call__(self, input): x = input.data y = self.forward(x) # 구체적인 계산은 forward 메서드에서 한다. output = Variable(y) return output def forward(self, x): raise NotImplementedError() NotImplementedError()는 ‘이 메서드는 상속하여 구현해야 한다’는 사실을 알려주는 예외처리 12345# steps/step02.py# 입력값을 제곱하는 클래스 구현class Square(Function): def forward(self, x): return x ** 2 12345x = Variable(np.array(10))f = Square()y = f(x)print(type(y))print(y.data) &lt;class '__main__.Variable'&gt; 100 3단계 함수 연결3.1 Exp 함수 구현 오일러의 수, 네이피어 상수 구현 1234# steps/step03.pyclass Exp(Function): def forward(self, x): return np.exp(x) 3.2 함수 연결12345678910# steps/step03.pyA = Square()B = Exp()C = Square()x = Variable(np.array(0.5))a = A(x)b = B(a)y = C(b)print(y.data) 1.648721270700128 여러 함수로 구성된 함수를 ‘합성 함수’라고 함 4단계 수치 미분4.1 미분이란 미분은 변화율 극한으로 짧은 시간(순간)에서의 변화량 도함수 : 함수 f(x)가 주어졌을 때 함수의 정의역에 속하는 각각의 x의 값에 미분계수가 하나씩 대응되는 함수 4.2 수치 미분 구현 컴퓨터는 극한을 취급할 수 없음 h = 0.0001(=1e-4)과 같은 매우 작은 값으로 대체 미세한 차이를 이용하여 함수의 변화량을 구하는 방법을 ‘수치 미분’이라 함 수치 미분은 작은 값을 사용하여 ‘진정한 미분’을 근사 어쩔수 없이 오차가 포함 근사 오차를 줄이는 방법으로 ‘중앙차분’을 씀 중앙차분은 f(x)와 f(x+h)의 차이를 구한는 대신에 f(x-h)와 f(x+h)의 차이를 구함 전진차분보다 중앙차분이 진정한 미분값에 가깝다는 사실은 테일러 급수를 이용해 증명가능 중앙차분을 이용하여 수치 비분을 계산하는 함수 numerical_diff(f, x, eps=1e-4)을 구현 f는 Function의 인스턴스, x는 미분을 계산하는 변수로 Variable 인스턴스, eps은 작은 값 1234567# steps/step04.pydef numerical_diff(f, x, eps=1e-4): x0 = Variable(x.data - eps) x1 = Variable(x.data + eps) y0 = f(x0) y1 = f(x1) return (y1.data - y0.data) / (2 * eps) 123456# steps/step04.py# Square 클래스를 대상으로 미분f = Square()x = Variable(np.array(2.0))dy = numerical_diff(f, x)print(dy) 4.000000000004 4.3 합성 함수의 미분 합성 함수를 미분해보자 1234567891011# steps/step04.pydef f(x): A = Square() B = Exp() C = Square() return C(B(A(x)))x = Variable(np.array(0.5))dy = numerical_diff(f, x)print(dy) 3.2974426293330694 4.4 수치 미분의 문제점 수치 미분의 결과에는 오차가 포함 대부분의 경우 오차는 매우 작지만 어떤 계산이냐에 따라 커질 수 있음 수치 미분의 결과에 오차가 포함되기 쉬운 이유는 주로 ‘자릿수 누락’ 때문 계산량이 많다는 점도 심각한 문제 그래서 등장한 것이 ‘역전파’ 역전파는 복잡한 알고리즘이라서 구현하면서 버그가 섞여 들어가기 쉬움 역전파를 정확하게 구현했는지 확인하기 위해 수치 미분의 결과를 이용하는 방식을 ‘기울기 확인’이라함 기울기 확인 : 단순히 수치 미분 결과와 역전파의 결과를 비교 5단계 역전파 이론 역전파을 이용하면 미분을 효율적으로 계산할 수 있고 결과값의 오차도 적음 5.1 연쇄 법칙 역전파를 이해하는 열쇠는 ‘연쇄 법칙(chain rule)’ 연쇄 법칙에 따르면 합성 함수의 미분은 구성 함수 각각을 미분한 후 곱한 것과 같음 5.2 역전파 원리 도출 머신러닝은 주로 대량의 매개변수를 입력받아서 마지막에 ‘손실 함수(loss function)’를 거쳐 출력을 내는 형태 손실 함수의 출력은 단일한 스칼라값이며, 이 값이 ‘중요 요소’ 머신러닝은 주로 대량의 매개변수를 입력받아서 마지막에 ‘손실 함수(loss function)’를 거쳐 출력을 내는 형태 미분값을 출력에서 입력 방향으로 전파하면 한 번의 전파만으로 모든 매개변수에 대한 미분을 계산할 수 있음 5.3 계산 그래프로 살펴보기 변수는 ‘통상값’과 ‘미분값’이 존재 함수는 ‘통상 계산(순전파)’과 ‘미분값을 구하기 위한 계산(역전파)’이 존재 역전파 시에는 순전파시에 이용한 데이터가 필요, 따라서 역전파를 구현하려면 먼저 순전파를 하고, 이때 각 함수가 입력 변수의 값을 기억해둬야함 6단계 수동 역전파 역전파의 구동 원리를 설명 Variable과 Function 클래스를 확장하여 역전파를 이용한 미분 구현 6.1 Variable 클래스 추가 구현 통산값(data)과 더불어 그에 대응하는 미분값(grad)도 저장하도록 확장 12345# steps/step06.pyclass Variable: def __init__(self, data): self.data = data self.grad = None 6.2 Function 클래스 추가 구현 미분을 계산하는 역전파(backward 메서드) forward 메서드 호출 시 건네받은 Variable 인스턴스 유지 1234567891011121314# steps/step06.pyclass Function: def __call__(self, input): x = input.data y = self.forward(x) output = Variable(y) self.input = input # 입력 변수를 기억(보관)함 return output def forward(self, x): raise NotImplementedError() def backward(self, gy): raise NotImplementedError() __call__ 메서드에서 입력된 input을 인스턴스 변수인 self.input에 저장 backward 메서드에서 함수에 입력한 변수가 필요할 때 self.input에서 가져와 사용 6.3 Square 와 Exp 클래스 추가 구현12345678910# steps/step06.pyclass Square(Function): def forward(self, x): y = x ** 2 return y def backward(self, gy): x = self.input.data gx = 2 * x * gy return gx 12345678910# steps/step06.pyclass Exp(Function): def forward(self, x): y = np.exp(x) return y def backward(self, gy): x = self.input.data gx = np.exp(x) * gy return gx 순전파 코드 123456789# steps/step06.pyA = Square()B = Exp()C = Square()x = Variable(np.array(0.5))a = A(x)b = B(a)y = C(b) 역전파 코드 123456# steps/step06.pyy.grad = np.array(1.0)b.grad = C.backward(y.grad)a.grad = B.backward(b.grad)x.grad = A.backward(a.grad)print(x.grad) 3.297442541400256 7단계 역전파 자동화 순전파를 한 번만 해주면 어떤 계산이라도 상관없이 역전파가 자동으로 이루어지는 구조 만들기 Define-by-Run이란 딥러닝에서 수행하는 계산들을 계산 시점에 ‘연결’하는 방식으로, ‘동적 계산 그래프’라고 함 7.1 역전파 자동화의 시작 역전파 자동화로 가는 길은 변수와 함수의 ‘관계’를 이해하는 데서 출발 함수 관점에서 변수는 ‘입력’과 ‘출력’에 쓰임 변수 과점에서 함수는 ‘창조자’ 혹은 ‘부모’ 일반적인 순전파가 이루어지는 시점에 ‘관계’를 맺어줌 123456789# steps/step07.pyclass Variable: def __init__(self, data): self.data = data self.grad = None self.creator = None # 인스턴스 변수 추가 def set_creator(self, func): # creator 설정 self.creator = func creator라는 인스턴스 변수 추가, creator 설정을 위한 set_creator 메서드 추가 12345678910# steps/step07.pyclass Function: def __call__(self, input): x = input.data y = self.forward(x) output = Variable(y) output.set_creator(self) # Set parent(function) self.input = input self.output = output # Set output return output 순전파를 계산하면 그 결과로 output이라는 Variable 인스턴스가 생성 oupput이 creator를 기억 123456789101112131415A = Square()B = Exp()C = Square()x = Variable(np.array(0.5))a = A(x)b = B(a)y = C(b)assert y.creator == Cassert y.creator.input == bassert y.creator.input.creator == Bassert y.creator.input.creator.input == aassert y.creator.input.creator.input.creator == Aassert y.creator.input.creator.input.creator.input == x assert문은 조건을 충족하는지 여부를 확인하는 데 사용 7.2 역전파 도전! 함수를 가져온다. 함수의 입력을 가져온다. 함수의 backward 메서드를 호출한다. 12345y.grad = np.array(1.0)C = y.creator # 1. 함수를 가져온다.b = C.input # 2. 함수의 입력을 가져온다.b.grad = C.backward(y.grad) # 3. 함수의 backward 메서드를 호출한다. 123B = b.creator # 1. 함수를 가져온다.a = B.input # 2. 함수의 입력을 가져온다.a.grad = B.backward(b.grad) # 3. 함수의 backward 메서드를 호출한다. 1234A = a.creator # 1. 함수를 가져온다.x = A.input # 2. 함수의 입력을 가져온다.x.grad = A.backward(a.grad) # 3. 함수의 backward 메서드를 호출한다.print(x.grad) 3.297442541400256 7.3 backward 메서드 추가 위 반복작업을 자동화할 수 있도록 Variable 클래스에 backward 메서드 추가 12345678910111213141516# steps/step07.pyclass Variable: def __init__(self, data): self.data = data self.grad = None self.creator = None def set_creator(self, func): self.creator = func def backward(self): f = self.creator # 1. Get a function if f is not None: x = f.input # 2. Get the function's input x.grad = f.backward(self.grad) # 3. Call the function's backward x.backward() backward 메서드가 재귀적으로 호출면서 자동화 12345678910111213A = Square()B = Exp()C = Square()x = Variable(np.array(0.5))a = A(x)b = B(a)y = C(b)# backwardy.grad = np.array(1.0)y.backward()print(x.grad) 3.297442541400256 8단계 재귀에서 반복문으로 처리 효율을 개선하고 확장을 대비해 backward 메서드의 구현 방식을 변경 8.2 반복문을 이용한 구현12345678910111213141516171819# steps/step08.pyclass Variable: def __init__(self, data): self.data = data self.grad = None self.creator = None def set_creator(self, func): self.creator = func def backward(self): funcs = [self.creator] while funcs: f = funcs.pop() # 1. Get a function x, y = f.input, f.output # 2. Get the function's input/output x.grad = f.backward(y.grad) # 3. Call the function's backward if x.creator is not None: funcs.append(x.creator) 처리해야 할 함수들을 funcs라는 리스트에 차례로 집어넣음 while 블록 안에서 funcs.pop()을 호출하여 처리할 함수 f를 꺼냄 f의 backward 메서드를 호출 f.input과 f.output에서 함수 f의 입력과 출력 변수를 얻음 f.backward()의 인수와 반환값을 올바르게 설정 1234567891011121314# steps/step08.pyA = Square()B = Exp()C = Square()x = Variable(np.array(0.5))a = A(x)b = B(a)y = C(b)# backwardy.grad = np.array(1.0)y.backward()print(x.grad) 3.297442541400256 재귀는 함수를 재귀적으로 호출할 때마다 중간 결과를 메모리에 유지하면서 처리 일반적으로 반복문 방식의 효율이 더 좋음 9단계 함수를 더 편리하게9.1 파이썬 함수로 이용하기12def square(x): return Square()(x) 12def exp(x): return Exp()(x) 12345678x = Variable(np.array(0.5))a = square(x)b = exp(a)y = square(b)y.grad = np.array(1.0)y.backward()print(x.grad) 3.297442541400256 123456# 함수를 연속하여 적용x = Variable(np.array(0.5))y = square(exp(square(x)))y.grad = np.array(1.0)y.backward()print(x.grad) 3.297442541400256 9.2 backward 메서드 간소화12345678910111213141516171819202122# y.grad = np.array(1.0) 생략 위해 Variable에 backward 수정class Variable: def __init__(self, data): self.data = data self.grad = None self.creator = None def set_creator(self, func): self.creator = func def backward(self): if self.grad is None: # grad가 None이면 미분값 생성 self.grad = np.ones_like(self.data) funcs = [self.creator] while funcs: f = funcs.pop() x, y = f.input, f.output x.grad = f.backward(y.grad) if x.creator is not None: funcs.append(x.creator) 1234x = Variable(np.array(0.5))y = square(exp(square(x)))y.backward()print(x.grad) 3.297442541400256 9.3 ndarray 만 취급하기 Variable에 ndarray인스턴스 외의 데이터를 넣을 경우 즉시 오류를 일으킴 1234567891011121314151617181920212223242526# steps/step09.pyclass Variable: def __init__(self, data): if data is not None: if not isinstance(data, np.ndarray): raise TypeError('{} is not supported'.format(type(data))) self.data = data self.grad = None self.creator = None def set_creator(self, func): self.creator = func def backward(self): if self.grad is None: # grad가 None이면 미분값 생성 self.grad = np.ones_like(self.data) funcs = [self.creator] while funcs: f = funcs.pop() x, y = f.input, f.output x.grad = f.backward(y.grad) if x.creator is not None: funcs.append(x.creator) data가 None이 아니고 ndarray 인스턴스도 아니면 TypeError 예외 발생 1234# steps/step09.pyx = Variable(np.array(1.0)) # OKx = Variable(None) # OKx = Variable(1.0) # NG --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-53-33bce631aee3&gt; in &lt;module&gt; 2 x = Variable(np.array(1.0)) # OK 3 x = Variable(None) # OK ----&gt; 4 x = Variable(1.0) # NG &lt;ipython-input-50-830a6874675c&gt; in __init__(self, data) 3 if data is not None: 4 if not isinstance(data, np.ndarray): ----&gt; 5 raise TypeError('{} is not supported'.format(type(data))) 6 7 self.data = data TypeError: &lt;class 'float'&gt; is not supported ndarray나 None이면 아무 문제 없지만, 다른 데이터 타입을 입력하면 예외 발생 잘못된 데이터 타입을 사용했음을 즉시 알 수 있음 1234x = np.array([1.0])y = x ** 2print(type(x), x.ndim)print(type(y)) &lt;class 'numpy.ndarray'&gt; 1 &lt;class 'numpy.ndarray'&gt; x는 1차원 ndarray y의 데이터 타입도 ndarray 1234x = np.array(1.0) # 0차원 ndarrayy = x ** 2print(type(x), x.ndim)print(type(y)) &lt;class 'numpy.ndarray'&gt; 0 &lt;class 'numpy.float64'&gt; x는 0차원의 ndarray인데, 제곱(x**2)을 하면 np.float64가 되어버림 Variable은 데이터가 항상 ndarray 인스턴스라고 가정하기 때문에 대처를 해줘야 함 12345# steps/step09.pydef as_array(x): if np.isscalar(x): return np.array(x) return x np.isscalar는 입력 데이터가 numpy.float64 같은 스칼라 타입인지 확인하는 함수 12import numpy as npnp.isscalar(np.float64(1.0)) True 1np.isscalar(2.0) True 1np.isscalar(np.array(1.0)) False 1np.isscalar(np.array([1, 2, 3])) False 이처럼 x가 스칼라 타입인지 쉽게 확인 가능 as_array함수는 입력이 스칼라인 경우 ndarray 인스턴스로 변환 as_array라는 편의 함수가 준비되었으니 Function 클래스에 코드 추가 12345678910111213141516# steps/step09.pyclass Function: def __call__(self, input): x = input.data y = self.forward(x) output = Variable(as_array(y)) # 편의 함수 추가 output.set_creator(self) self.input = input self.output = output return output def forward(self, x): raise NotImplementedError() def backward(self, gy): raise NotImplementedError() 순전파의 결과인 y를 Variable로 감쌀 때 as_array()를 이용 출력 결과인 output은 항상 ndarray 인스턴스가 되도록 보장 이제 0차원 ndarray 인스턴스를 사용한 계산도 모든 데이터가 ndarray 인스턴스 10단계 테스트 간단한 테스트를 해보자 10.1 파이썬 단위 테스트 파이썬으로 테스트할 때 표준 라이브러리에 포함된 nuittest를 사용하면 편함 12345678910# 이전 단계에서 구현한 square 함수 테스트# steps/step10.pyimport unittestclass SquareTest(unittest.TestCase): def test_forward(self): x = Variable(np.array(2.0)) y = square(x) expected = np.array(4.0) self.assertEqual(y.data, expected) unittest를 임포트하고 nuittest.TestCase를 상속한 SquareTest 클래스를 구현 square 함수의 출력이 기댓값과 같은지 확인 self.assertEqual 메서드는 주어진 두 객체가 동일한지 여부를 판정 1$ python -m unittest steps/step10.py python 명령을 실행할 때 -m unittest 인수를 제공하면 파이썬 파일을 테스트 모드로 실행 파일 끝에 다음 코드를 추가하면 ‘python steps/step10.py’만 입력해도 테스트 수행1unittest.main() 10.2 square 함수의 역전파 테스트 1234567891011121314# steps/step10.pyclass SquareTest(unittest.TestCase): def test_forward(self): x = Variable(np.array(2.0)) y = square(x) expected = np.array(4.0) self.assertEqual(y.data, expected) def test_backward(self): x = Variable(np.array(3.0)) y = square(x) y.backward() expected = np.array(6.0) self.assertEqual(x.grad, expected) test_backward 메서드 추가 y.backward()로 미분값을 구하고, 그 값이 기댓값과 일치하는지 확인 10.3 기울기 확인을 이용한 자동 테스트 기울기 확인이란 수치 미분으로 구한 결과와 역전파로 구한 결과를 비교, 그 차이가 크면 역전파 구현에 문제가 있다고 판단하는 검증 기법 123456789101112131415161718192021222324252627282930# steps/step10.pydef numerical_diff(f, x, eps=1e-4): x0 = Variable(x.data - eps) x1 = Variable(x.data + eps) y0 = f(x0) y1 = f(x1) return (y1.data - y0.data) / (2 * eps)class SquareTest(unittest.TestCase): def test_forward(self): x = Variable(np.array(2.0)) y = square(x) expected = np.array(4.0) self.assertEqual(y.data, expected) def test_backward(self): x = Variable(np.array(3.0)) y = square(x) y.backward() expected = np.array(6.0) self.assertEqual(x.grad, expected) def test_gradient_check(self): x = Variable(np.random.rand(1)) y = square(x) y.backward() num_grad = numerical_diff(square, x) flg = np.allclose(x.grad, num_grad) self.assertTrue(flg) 기울기 확인을 할 test_gradient_check 메서드 안에서 무작위 입력값을 하나 생성 역전파로 미분값을 구하고, numerical_diff 함수를 사용해 수치 미분으로도 계산 두 메서드로 각각 구한 값들이 거의 일치하는지 확인 np.allclose(a, b)는 ndarray 인스턴스인 a와 b의 값이 가까운지 판정 얼마나 가까워야 가깐운 것인지는 np.allclose(a, b, rtol=1e-05, atol=1e-08)과 같이 인수 rtol과 atol로 지정 가능 a와 b의 모든 요소가 다음 조건을 만족하면 True 반환1|a - b| &lt;= (atol + rtol * |b|)","link":"/2021/03/05/%EC%A0%9C1%EA%B3%A0%EC%A7%80_%EB%AF%B8%EB%B6%84_%EC%9E%90%EB%8F%99%EA%B3%84%EC%82%B0/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"review","slug":"review","link":"/tags/review/"}],"categories":[{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"book","slug":"book","link":"/categories/book/"}]}